{"version":3,"file":"createSignalFunction.js","names":["createSignal","createSignalFunction","value","options","get","set","arguments","length"],"sources":["../src/createSignalFunction.ts"],"sourcesContent":["// FIXME Solid 1.7.9+ requires a TypeScript update, so classy-solid code is made\n// un-typesafe until we update.\n\n// import {createSignal} from './createDeferredEffect.js'\nimport {createSignal} from 'solid-js'\nimport type {Setter} from 'solid-js'\nimport type {SignalOptions} from 'solid-js/types/reactive/signal'\n\n/**\n * A single function that with no args passed reads a signal, otherwise sets a\n * signal just like a Setter does.\n */\nexport type SignalFunction<T> = {(): T} & Setter<T> // FIXME broke in 1.7.9\n\n/**\n * Create a Solid signal wrapped as a single function that gets the value when\n * no arguments are passed in, and sets the value when an argument is passed in.\n * Good for alternative usage patterns, such as when read/write segregation is\n * not needed.\n *\n * ```js\n * let count = createSignalFunction(0) // create it with default value\n * count(1) // set the value\n * count(count() + 1) // increment\n * let currentValue = count() // read the current value\n * ```\n *\n * This is more convenient for class properties than using `createSignal`. With `createSignal`:\n *\n * ```js\n * class Foo {\n *   count = createSignal(0)\n *\n *   increment() {\n *     // difficult to read\n *     this.count[1](this.count[0]() + 1)\n *\n *     // also:\n *     this.count[1](c => c + 1)\n *   }\n * }\n * ```\n *\n * With `createSignalFunction`:\n *\n * ```js\n * class Foo {\n *   count = createSignalFunction(0)\n *\n *   increment() {\n *     // Easier to read\n *     this.count(this.count() + 1)\n *\n *     // also:\n *     this.count(c => c + 1)\n *   }\n * }\n * ```\n *\n * See also `createSignalObject` for another pattern.\n */\nexport function createSignalFunction<T>(): SignalFunction<T | undefined>\nexport function createSignalFunction<T>(value: T, options?: SignalOptions<T>): SignalFunction<T>\nexport function createSignalFunction<T>(value?: T, options?: SignalOptions<T>): SignalFunction<T> {\n\tconst [get, set] = createSignal<T>(value as T, options)\n\n\treturn function (value) {\n\t\tif (arguments.length === 0) return get()\n\t\treturn set(\n\t\t\t// @ts-ignore FIXME its ok, value is defined (even if `undefined`)\n\t\t\tvalue,\n\t\t)\n\t} as SignalFunction<T>\n}\n"],"mappings":"AAAA;AACA;;AAEA;AACA,SAAQA,YAAY,QAAO,UAAU;;AAIrC;AACA;AACA;AACA;AACoD;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,OAAO,SAASC,oBAAoBA,CAAIC,KAAS,EAAEC,OAA0B,EAAqB;EACjG,MAAM,CAACC,GAAG,EAAEC,GAAG,CAAC,GAAGL,YAAY,CAAIE,KAAK,EAAOC,OAAO,CAAC;EAEvD,OAAO,UAAUD,KAAK,EAAE;IACvB,IAAII,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE,OAAOH,GAAG,CAAC,CAAC;IACxC,OAAOC,GAAG;IACT;IACAH,KACD,CAAC;EACF,CAAC;AACF"}