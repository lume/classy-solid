{"version":3,"file":"decoratorAbstraction.js","names":["decoratorAbstraction","decorator","handlerOrProtoOrFactoryArg","propName","descriptor","isDecoratorV2","classElement","finisher","Class","prototype","key","TypeError"],"sources":["../src/decoratorAbstraction.ts"],"sourcesContent":["import type {Constructor} from 'lowclass'\n\nexport function decoratorAbstraction(\n\tdecorator: (prototype: any, propName: string, _descriptor?: PropertyDescriptor) => void,\n\thandlerOrProtoOrFactoryArg?: any,\n\tpropName?: string,\n\tdescriptor?: PropertyDescriptor,\n) {\n\t// This is true only if we're using the decorator in a Babel-compiled app\n\t// with non-legacy decorators. TypeScript only has legacy decorators.\n\tconst isDecoratorV2 = handlerOrProtoOrFactoryArg && 'kind' in handlerOrProtoOrFactoryArg\n\n\tif (isDecoratorV2) {\n\t\tconst classElement = handlerOrProtoOrFactoryArg\n\n\t\treturn {\n\t\t\t...classElement,\n\t\t\tfinisher(Class: Constructor) {\n\t\t\t\tdecorator(Class.prototype, classElement.key)\n\t\t\t\treturn classElement.finisher?.(Class) ?? Class\n\t\t\t},\n\t\t}\n\t}\n\n\tif (handlerOrProtoOrFactoryArg && propName) {\n\t\t// if being used as a legacy decorator directly\n\t\tconst prototype = handlerOrProtoOrFactoryArg\n\t\treturn decorator(prototype, propName, descriptor)\n\t}\n\n\tthrow new TypeError('Invalid decorator')\n}\n"],"mappings":"AAEA,OAAO,SAASA,oBAAoBA,CACnCC,SAAuF,EACvFC,0BAAgC,EAChCC,QAAiB,EACjBC,UAA+B,EAC9B;EACD;EACA;EACA,MAAMC,aAAa,GAAGH,0BAA0B,IAAI,MAAM,IAAIA,0BAA0B;EAExF,IAAIG,aAAa,EAAE;IAClB,MAAMC,YAAY,GAAGJ,0BAA0B;IAE/C,OAAO;MACN,GAAGI,YAAY;MACfC,QAAQA,CAACC,KAAkB,EAAE;QAC5BP,SAAS,CAACO,KAAK,CAACC,SAAS,EAAEH,YAAY,CAACI,GAAG,CAAC;QAC5C,OAAOJ,YAAY,CAACC,QAAQ,GAAGC,KAAK,CAAC,IAAIA,KAAK;MAC/C;IACD,CAAC;EACF;EAEA,IAAIN,0BAA0B,IAAIC,QAAQ,EAAE;IAC3C;IACA,MAAMM,SAAS,GAAGP,0BAA0B;IAC5C,OAAOD,SAAS,CAACQ,SAAS,EAAEN,QAAQ,EAAEC,UAAU,CAAC;EAClD;EAEA,MAAM,IAAIO,SAAS,CAAC,mBAAmB,CAAC;AACzC"}