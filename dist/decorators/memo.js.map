{"version":3,"file":"memo.js","names":["createMemo","createWritableMemo","memoify","__sortSignalsMemosInMetadata","memo","_value","context","static","Error","kind","name","metadata","Object","hasOwn","signalFieldsAndMemos","signalsAndMemos","stat","find","key","push","type","applied","WeakMap","addInitializer","get","set","last","findLast","_","lastStat"],"sources":["../../src/decorators/memo.ts"],"sourcesContent":["import {createMemo} from 'solid-js'\nimport {createWritableMemo} from '@solid-primitives/memo'\nimport {memoify} from '../signals/memoify.js'\nimport type {SignalMetadata} from './types.js'\nimport {__sortSignalsMemosInMetadata} from '../signals/_state.js'\n\ncreateMemo\ncreateWritableMemo\n\n/**\n * A decorator that make a signal property derived from a memoized computation\n * based on other signals. Effects depending on this property will re-run when\n * the computed value changes, but not if the computed value stays the same even\n * if the dependencies changed.\n *\n * @example\n * ```ts\n * import {reactive, signal, memo} from \"classy-solid\";\n *\n * @reactive\n * class Example {\n *   @signal a = 1\n *   @signal b = 2\n *\n *   // @memo can be used on a field, getter, or accessor.\n *\n *   // Writable memo via field (requires arrow function, not great for TypeScript type inference)\n *   @memo sum = () => this.a + this.b\n *\n *   // Readonly memo via getter only\n *   @memo get sum2() {\n *     return this.a + this.b\n *   }\n *\n *   // Writable memo via accessor (requires arrow function, not great for TypeScript type inference)\n *   @memo accessor sum3 = () => this.a + this.b\n *\n *   // Readonly memo via method\n *   @memo sum4() {\n *     return this.a + this.b\n *   }\n *\n *   // The following variants are not supported yet as no runtime or TS support exists yet for the syntax.\n *\n *   // Writable memo via accessor, alternative long-hand syntax (not yet released, no runtime or TS support yet)\n *   @memo accessor sum5 { get; set } = () => this.a + this.b\n *\n *   // Readonly memo via accessor with only getter (not released yet, no runtime or TS support yet)\n *   @memo accessor sum6 { get; } = () => this.a + this.b\n *\n *   // Readonly memo via accessor with only getter, alternative syntax (not released yet, no runtime or TS support yet)\n *   @memo accessor sum7 {\n *     get() {\n *       return this.a + this.b\n *     }\n *   }\n * }\n *\n * const ex = new Example();\n *\n * console.log(ex.sum, ex.sum2, ex.sum3, ex.sum4);  // 3 3 3 3\n *\n * createEffect(() => {\n *   console.log(ex.sum, ex.sum2, ex.sum3, ex.sum4);\n * });\n *\n * ex.a = 5; // Logs: 7 7 7 7\n *\n * // This won't log anything since the computed memo values don't change (all still 7).\n * batch(() => {\n *   ex.a = 3;\n *   ex.b = 4;\n * })\n *\n * ex.sum = 20; // Logs: 20 7 7 7 (only sum is updated)\n * ```\n */\nexport function memo(\n\t_value:\n\t\t| undefined\n\t\t| ((val?: any) => any) // writable memo via field or method\n\t\t| (() => any) // readonly memo via field or method\n\t\t| ((val?: any) => void) // memo setter\n\t\t| (() => void) // memo getter\n\t\t| ClassAccessorDecoratorTarget<unknown, () => any> // today's auto-accessors, readonly memo\n\t\t| ClassAccessorDecoratorTarget<unknown, (val?: number) => any>, // today's auto-accessors, writable memo\n\t// | {get: () => any; set?: (v: any) => void} // future grouped accessors\n\t// | {get?: () => any; set: (v: any) => void}, // future grouped accessors\n\tcontext:\n\t\t| ClassFieldDecoratorContext\n\t\t| ClassGetterDecoratorContext\n\t\t| ClassSetterDecoratorContext\n\t\t// | ClassSetterDecoratorContext // memos are read-only\n\t\t| ClassAccessorDecoratorContext\n\t\t| ClassMethodDecoratorContext,\n) {\n\tif (context.static) throw new Error('@memo is not supported on static fields yet.')\n\n\tconst {kind, name} = context\n\n\tconst metadata = context.metadata as SignalMetadata\n\n\tif (!Object.hasOwn(metadata, 'signalFieldsAndMemos')) metadata.signalFieldsAndMemos = []\n\tconst signalsAndMemos = metadata.signalFieldsAndMemos!\n\n\tif (kind === 'field') {\n\t\tlet stat = signalsAndMemos.find(([key]) => key === name)?.[1]\n\t\tif (!stat) signalsAndMemos.push([name, (stat = {type: 'memo-field', applied: new WeakMap()})])\n\n\t\tcontext.addInitializer(function (this: object) {\n\t\t\t__sortSignalsMemosInMetadata(metadata)\n\n\t\t\tif (stat.applied.get(this as object)) return\n\t\t\tmemoify(this, name as keyof object)\n\t\t\tstat.applied.set(this as object, true)\n\n\t\t\tconst last = signalsAndMemos.findLast(\n\t\t\t\t([_, {type}]) => type === 'signal-field' || type === 'memo-field' || type === 'memo-auto-accessor',\n\t\t\t)!\n\t\t\tconst [, lastStat] = last\n\n\t\t\tif (stat !== lastStat) return\n\n\t\t\t// All signal-fields, memo-fields, and memo-auto-accessors have been\n\t\t\t// initialized. Now initialize memo fields that were waiting for\n\t\t\t// those to be ready.\n\t\t\tfor (const [key, stat] of signalsAndMemos) {\n\t\t\t\tif (!(stat.type === 'memo-accessor' || stat.type === 'memo-method') || stat.applied.get(this as object))\n\t\t\t\t\tcontinue\n\t\t\t\tmemoify(this as object, key as keyof object)\n\t\t\t}\n\t\t} as (this: unknown) => void)\n\t} else if (kind === 'accessor') {\n\t\tlet stat = signalsAndMemos.find(([key]) => key === name)?.[1]\n\t\tif (!stat) signalsAndMemos.push([name, (stat = {type: 'memo-auto-accessor', applied: new WeakMap()})])\n\n\t\tcontext.addInitializer(function (this: unknown) {\n\t\t\t__sortSignalsMemosInMetadata(metadata)\n\n\t\t\tif (stat.applied.get(this as object)) return\n\t\t\tmemoify(this as object, true, name as keyof object)\n\t\t\tstat.applied.set(this as object, true)\n\n\t\t\tconst last = signalsAndMemos.findLast(\n\t\t\t\t([_, {type}]) => type === 'signal-field' || type === 'memo-field' || type === 'memo-auto-accessor',\n\t\t\t)!\n\t\t\tconst [, lastStat] = last\n\n\t\t\tif (stat !== lastStat) return\n\n\t\t\t// All signal-fields, memo-fields, and memo-auto-accessors have been\n\t\t\t// initialized. Now initialize memo fields that were waiting for\n\t\t\t// those to be ready.\n\t\t\tfor (const [key, stat] of signalsAndMemos) {\n\t\t\t\tif (!(stat.type === 'memo-accessor' || stat.type === 'memo-method') || stat.applied.get(this as object))\n\t\t\t\t\tcontinue\n\t\t\t\tmemoify(this as object, key as keyof object)\n\t\t\t}\n\t\t})\n\t} else if (kind === 'method') {\n\t\tlet stat = signalsAndMemos.find(([key]) => key === name)?.[1]\n\t\tif (!stat) signalsAndMemos.push([name, (stat = {type: 'memo-method', applied: new WeakMap()})])\n\n\t\tcontext.addInitializer(function (this: unknown) {\n\t\t\t__sortSignalsMemosInMetadata(metadata)\n\n\t\t\t// If any signal-fields, memo-fields, or memo-auto-accessors are\n\t\t\t// defined on the class before this memo field, skip memoifying now.\n\t\t\t// We'll memoify later after signal fields are initialized\n\t\t\tfor (const [key, stat] of signalsAndMemos) {\n\t\t\t\tif (\n\t\t\t\t\t(stat.type === 'signal-field' || stat.type === 'memo-field' || stat.type === 'memo-auto-accessor') &&\n\t\t\t\t\t!stat.applied.get(this as object)\n\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\tif (key === name) break // reached our own memo field, no prior signal-fields or memo-auto-accessors found\n\t\t\t}\n\n\t\t\tmemoify(this as object, name as keyof object)\n\t\t})\n\t} else if (kind === 'getter' || kind === 'setter') {\n\t\t// if (!Object.hasOwn(metadata, 'memoStoragesPerProp')) metadata.memoStoragesPerProp = {}\n\t\t// const memoStorages = metadata.memoStoragesPerProp as MemoStorages\n\n\t\t// let memoStorage = memoStorages[name]\n\t\t// if (!memoStorage) memoStorages[name] = memoStorage = {storage: new WeakMap()}\n\n\t\t// if (!Object.hasOwn(metadata, 'getterSetterPairs')) metadata.getterSetterPairs = {}\n\t\t// const pairs = metadata.getterSetterPairs as {[key: PropKey]: 0 | 1 | 2}\n\n\t\t// context.addInitializer(function (this: unknown) {\n\t\t// \t// Show a helpful error in case someone forgets to decorate both a getter and setter.\n\t\t// \t// Best effort: this error may not always show, f.e. if a subclass overrides with only a getter.\n\t\t// \tif (getInheritedDescriptor(this as object, name as keyof object)?.set)\n\t\t// \t\tif (pairs[name] !== 2) throw new MissingDecoratorError(name)\n\n\t\t// \t// CONTINUE: this runs too early, before signals fields. :(\n\t\t// \tmemoStorage.storage.set(this as object, createWritableMemo(memoStorage.getter!))\n\t\t// })\n\n\t\t// if (kind === 'getter') {\n\t\t// \tpairs[name] ??= 0\n\t\t// \tpairs[name]++\n\n\t\t// \tconst getter = value as () => unknown\n\t\t// \tmemoStorage.getter = getter\n\n\t\t// \tconst newGetter = function (this: object): unknown {\n\t\t// \t\tconst [read] = memoStorage.storage.get(this)!\n\t\t// \t\treturn read()\n\t\t// \t}\n\n\t\t// \tisMemoGetter.add(newGetter)\n\n\t\t// \treturn newGetter\n\t\t// } else {\n\t\t// \tpairs[name] ??= 0\n\t\t// \tpairs[name]++\n\n\t\t// \t// const setter = value as (val: unknown) => void\n\n\t\t// \treturn function (this: object, newValue: any): any {\n\t\t// \t\t// setter.call(this, newValue)\n\t\t// \t\t// const s = __getMemo(this, memoStorage.storage, setter)\n\t\t// \t\tconst [_, s] = memoStorage.storage.get(this)!\n\t\t// \t\ts(typeof newValue === 'function' ? () => newValue : newValue)\n\t\t// \t} as any // TypeScript type error workaround\n\t\t// }\n\n\t\tlet stat = signalsAndMemos.find(([key]) => key === name)?.[1]\n\t\tif (!stat) signalsAndMemos.push([name, (stat = {type: 'memo-accessor', applied: new WeakMap()})])\n\n\t\tcontext.addInitializer(function (this: unknown) {\n\t\t\t__sortSignalsMemosInMetadata(metadata)\n\n\t\t\t// If any signal-fields, memo-fields, or memo-auto-accessors are\n\t\t\t// defined on the class before this memo field, skip memoifying now.\n\t\t\t// We'll memoify later after signal fields are initialized\n\t\t\tfor (const [key, stat] of signalsAndMemos) {\n\t\t\t\tif (\n\t\t\t\t\t(stat.type === 'signal-field' || stat.type === 'memo-field' || stat.type === 'memo-auto-accessor') &&\n\t\t\t\t\t!stat.applied.get(this as object)\n\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\tif (key === name) break // reached our own memo field, no prior signal-fields or memo-auto-accessors found\n\t\t\t}\n\n\t\t\tmemoify(this as object, name as keyof object)\n\t\t})\n\t}\n}\n\n// class MissingDecoratorError extends Error {\n// \tconstructor(prop: PropertyKey) {\n// \t\tsuper(\n// \t\t\t`Missing @memo decorator on setter or getter for property \"${String(\n// \t\t\t\tprop,\n// \t\t\t)}\". The @memo decorator will only work on a getter/setter pair with *both* getter and setter decorated with @memo.`,\n// \t\t)\n// \t}\n// }\n\n// function __getMemo(obj: object, storage: MemoStorage, fn: () => unknown) {\n// \tlet m = storage.get(obj)\n// \tif (!m) storage.set(obj, (m = createWritableMemo(fn)))\n// \treturn m\n// }\n"],"mappings":"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","ignoreList":[]}