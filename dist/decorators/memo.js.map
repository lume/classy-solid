{"version":3,"file":"memo.js","names":["finalizeMembersIfLast","getMemberStat","getMembers","memoifyIfNeeded","memo","value","context","static","Error","kind","name","metadata","signalsAndMemos","memberType","stat","finalize","addInitializer","get"],"sources":["../../src/decorators/memo.ts"],"sourcesContent":["import type {AnyObject, ClassySolidMetadata} from './types.js'\nimport {finalizeMembersIfLast, getMemberStat, getMembers, memoifyIfNeeded} from '../_state.js'\nimport './metadata-shim.js'\n\n/**\n * A decorator that make a signal property derived from a memoized computation\n * based on other signals. Effects depending on this property will re-run when\n * the computed value changes, but not if the computed value stays the same even\n * if the dependencies changed.\n *\n * @example\n * ```ts\n * import {reactive, signal, memo} from \"classy-solid\";\n *\n * class Example {\n *   @signal a = 1\n *   @signal b = 2\n *\n *   // @memo can be used on a getter, accessor, or method, with readonly and\n *   // writable variants:\n *\n *   // Readonly memo via getter only\n *   @memo get sum1() {\n *     return this.a + this.b\n *   }\n *\n *   // Writable memo via getter with setter\n *   @memo get sum2() {\n *     return this.a + this.b\n *   }\n *   @memo set sum2(value: number) {\n *     // use an empty setter to enable writable (logic in here will be ignored if any)\n *   }\n *\n *   // Readonly memo via auto accessor (requires arrow function, not writable because no parameter (arity = 0))\n *   @memo accessor sum3 = () => this.a + this.b\n *\n *   // Writable memo via auto accessor (requires arrow function with parameter, arity > 0)\n *   // Ignore the parameter, it only enables writable memo\n *   @memo accessor sum4 = (v?: number) => this.a + this.b\n *\n *   // Readonly memo via method\n *   @memo sum5() {\n *     return this.a + this.b\n *   }\n *\n *   // Writable memo via method with parameter (arity > 0)\n *   @memo sum6(value?: number) {\n *     // Ignore the parameter, it only enables writable memo\n *     return this.a + this.b\n *   }\n *\n *   // The following variants are not supported yet as no runtime or TS support exists yet for the syntax.\n *\n *   // Writable memo via accessor, alternative long-hand syntax (not yet released, no runtime or TS support yet)\n *   @memo accessor sum6 { get; set } = () => this.a + this.b\n *\n *   // Readonly memo via accessor with only getter (not released yet, no runtime or TS support yet)\n *   @memo accessor sum7 { get; } = () => this.a + this.b\n *\n *   // Readonly memo via accessor with only getter, alternative syntax (not released yet, no runtime or TS support yet)\n *   @memo accessor sum8 {\n *     get() {\n *       return this.a + this.b\n *     }\n *   }\n *\n *   // Readonly memo via accessor with only getter, alternative syntax (not released yet, no runtime or TS support yet)\n *   @memo accessor sum8 {\n *     get() {\n *       return this.a + this.b\n *     }\n *     set(_v: number) {\n *       // empty setter makes it writable (logic in here will be ignored if any)\n *     }\n *   }\n * }\n *\n * const ex = new Example()\n *\n * console.log(ex.sum1, ex.sum2, ex.sum3(), ex.sum4(), ex.sum5(), ex.sum6()) // 3 3 3 3 3 3\n *\n * createEffect(() => {\n *   console.log(ex.sum1, ex.sum2, ex.sum3(), ex.sum4(), ex.sum5(), ex.sum6())\n * });\n *\n * ex.a = 5 // Logs: 7 7 7 7 7 7\n *\n * // This won't log anything since the computed memo values don't change (all still 7).\n * batch(() => {\n *   ex.a = 3\n *   ex.b = 4\n * })\n *\n * ex.sum2 = 20 // Logs: 20 7 7 7 7 7 (only sum2 is updated)\n *\n * ex.sum6(15) // Logs: 20 7 7 7 7 15 (only sum6 is updated)\n *\n * ex.sum1 = 10 // Runtime error: Cannot set readonly property \"sum1\".\n * ```\n */\nexport function memo(\n\tvalue:\n\t\t| ((val?: any) => any) // writable memo via field or method\n\t\t| (() => any) // readonly memo via field or method\n\t\t| ((val?: any) => void) // memo setter\n\t\t| (() => void) // memo getter\n\t\t| ClassAccessorDecoratorTarget<unknown, () => any> // today's auto-accessors, readonly memo\n\t\t| ClassAccessorDecoratorTarget<unknown, (val?: number) => any>, // today's auto-accessors, writable memo\n\tcontext:\n\t\t| ClassGetterDecoratorContext\n\t\t| ClassSetterDecoratorContext\n\t\t| ClassAccessorDecoratorContext\n\t\t| ClassMethodDecoratorContext,\n) {\n\tif (context.static) throw new Error('@memo is not supported on static fields yet.')\n\n\tconst {kind, name} = context\n\tconst metadata = context.metadata as ClassySolidMetadata\n\tconst signalsAndMemos = getMembers(metadata)\n\n\t// Apply finalization logic to all except setters (setters are finalized\n\t// together with their getters).\n\t// By skipping setters we also avoid double-counting the getter+setter pair\n\t// in the finalizeMembersIfLast logic.\n\tif (kind === 'setter') return\n\n\t// @ts-expect-error skip type checking in case of invalid kind in plain JS\n\tif (kind === 'field') throw new Error('@memo is not supported on class fields.')\n\n\tconst memberType = kind === 'accessor' ? 'memo-auto-accessor' : kind === 'method' ? 'memo-method' : 'memo-accessor'\n\n\tconst stat = getMemberStat(name, memberType, signalsAndMemos)\n\n\tstat.finalize = function (this: unknown) {\n\t\tmemoifyIfNeeded(this as AnyObject, name, stat)\n\t}\n\n\tcontext.addInitializer(function () {\n\t\tfinalizeMembersIfLast(this as AnyObject, signalsAndMemos)\n\t})\n\n\tif (kind === 'method' || kind === 'getter') stat.value = value\n\telse if (kind === 'accessor') stat.value = (value as ClassAccessorDecoratorTarget<unknown, () => void>).get\n}\n"],"mappings":"AACA,SAAQA,qBAAqB,EAAEC,aAAa,EAAEC,UAAU,EAAEC,eAAe,QAAO,cAAc;AAC9F,OAAO,oBAAoB;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,IAAIA,CACnBC,KAM+D;AAAE;AACjEC,OAI8B,EAC7B;EACD,IAAIA,OAAO,CAACC,MAAM,EAAE,MAAM,IAAIC,KAAK,CAAC,8CAA8C,CAAC;EAEnF,MAAM;IAACC,IAAI;IAAEC;EAAI,CAAC,GAAGJ,OAAO;EAC5B,MAAMK,QAAQ,GAAGL,OAAO,CAACK,QAA+B;EACxD,MAAMC,eAAe,GAAGV,UAAU,CAACS,QAAQ,CAAC;;EAE5C;EACA;EACA;EACA;EACA,IAAIF,IAAI,KAAK,QAAQ,EAAE;;EAEvB;EACA,IAAIA,IAAI,KAAK,OAAO,EAAE,MAAM,IAAID,KAAK,CAAC,yCAAyC,CAAC;EAEhF,MAAMK,UAAU,GAAGJ,IAAI,KAAK,UAAU,GAAG,oBAAoB,GAAGA,IAAI,KAAK,QAAQ,GAAG,aAAa,GAAG,eAAe;EAEnH,MAAMK,IAAI,GAAGb,aAAa,CAACS,IAAI,EAAEG,UAAU,EAAED,eAAe,CAAC;EAE7DE,IAAI,CAACC,QAAQ,GAAG,YAAyB;IACxCZ,eAAe,CAAC,IAAI,EAAeO,IAAI,EAAEI,IAAI,CAAC;EAC/C,CAAC;EAEDR,OAAO,CAACU,cAAc,CAAC,YAAY;IAClChB,qBAAqB,CAAC,IAAI,EAAeY,eAAe,CAAC;EAC1D,CAAC,CAAC;EAEF,IAAIH,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,QAAQ,EAAEK,IAAI,CAACT,KAAK,GAAGA,KAAK,MACzD,IAAII,IAAI,KAAK,UAAU,EAAEK,IAAI,CAACT,KAAK,GAAIA,KAAK,CAAuDY,GAAG;AAC5G","ignoreList":[]}