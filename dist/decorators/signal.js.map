{"version":3,"file":"signal.js","names":["batch","getSignal__","trackPropSetAtLeastOnce__","isSignalGetter","getMemberStat","finalizeMembersIfLast","getMembers","signalifyIfNeeded","Undefined","Symbol","signal","value","context","static","Error","kind","name","metadata","signalsAndMemos","InvalidSignalDecoratorError","stat","finalize","addInitializer","get","set","signalStorage","WeakMap","initialValue","undefined","newValue","init","initialVal","call","s","add","getOrSet","Object","hasOwn","classySolid_getterSetterSignals","signalsStorages","classySolid_getterSetterPairCounts","pairs","queueMicrotask","missing","MissingSignalDecoratorError","newGetter","newSetter","constructor","prop","String"],"sources":["../../src/decorators/signal.ts"],"sourcesContent":["import {batch} from 'solid-js'\nimport {getSignal__, trackPropSetAtLeastOnce__} from '../signals/signalify.js'\nimport type {AnyObject, ClassySolidMetadata} from './types.js'\nimport type {SignalFunction} from '../signals/createSignalFunction.js'\nimport {isSignalGetter, getMemberStat, finalizeMembersIfLast, getMembers, signalifyIfNeeded} from '../_state.js'\nimport './metadata-shim.js'\n\nconst Undefined = Symbol()\n\n/**\n * @decorator\n * Decorate properties of a class with `@signal` to back them with Solid\n * signals, making them reactive.\n *\n * Related: See the Solid.js `createSignal` API for creating standalone signals.\n *\n * Example:\n *\n * ```js\n * import {signal} from 'classy-solid'\n * import {createEffect} from 'solid-js'\n *\n * class Counter {\n *   â£@signal count = 0\n *\n *   constructor() {\n *     setInterval(() => this.count++, 1000)\n *   }\n * }\n *\n * const counter = new Counter()\n *\n * createEffect(() => {\n *   console.log('count:', counter.count)\n * })\n * ```\n */\nexport function signal(\n\tvalue: unknown,\n\tcontext:\n\t\t| ClassFieldDecoratorContext\n\t\t| ClassGetterDecoratorContext\n\t\t| ClassSetterDecoratorContext\n\t\t| ClassAccessorDecoratorContext,\n): any {\n\tif (context.static) throw new Error('@signal is not supported on static fields yet.')\n\n\tconst {kind, name} = context\n\tconst metadata = context.metadata as ClassySolidMetadata\n\tconst signalsAndMemos = getMembers(metadata)\n\n\tif (!(kind === 'field' || kind === 'accessor' || kind === 'getter' || kind === 'setter'))\n\t\tthrow new InvalidSignalDecoratorError()\n\n\tif (kind === 'field') {\n\t\tconst stat = getMemberStat(name, 'signal-field', signalsAndMemos)\n\n\t\tstat.finalize = function (this: unknown) {\n\t\t\tsignalifyIfNeeded(this as AnyObject, name, stat)\n\t\t}\n\n\t\tcontext.addInitializer(function () {\n\t\t\tfinalizeMembersIfLast(this as AnyObject, signalsAndMemos)\n\t\t})\n\t}\n\n\t// It's ok that getters/setters/auto-accessors are not finalized the same\n\t// way as with fields above and as with memos/effects, because we do the set\n\t// up during decoration which happens well before any initializers (before\n\t// any memos and effects, so these will be tracked).\n\telse if (kind === 'accessor') {\n\t\tconst {get, set} = value as {get: () => unknown; set: (v: unknown) => void}\n\t\tconst signalStorage = new WeakMap<object, SignalFunction<unknown>>()\n\t\tlet initialValue: unknown = undefined\n\n\t\tconst newValue = {\n\t\t\tinit: function (this: object, initialVal: unknown) {\n\t\t\t\tinitialValue = initialVal\n\t\t\t\treturn initialVal\n\t\t\t},\n\t\t\tget: function (this: object): unknown {\n\t\t\t\tgetSignal__(this, signalStorage, initialValue)()\n\t\t\t\treturn get.call(this)\n\t\t\t},\n\t\t\tset: function (this: object, newValue: unknown) {\n\t\t\t\t// batch, for example in case setter calls super setter, to\n\t\t\t\t// avoid multiple effect runs on a single property set.\n\t\t\t\tbatch(() => {\n\t\t\t\t\tset.call(this, newValue)\n\t\t\t\t\ttrackPropSetAtLeastOnce__(this, name) // not needed anymore? test it\n\n\t\t\t\t\tconst s = getSignal__(this, signalStorage, initialValue)\n\t\t\t\t\ts(typeof newValue === 'function' ? () => newValue : newValue)\n\t\t\t\t})\n\t\t\t},\n\t\t}\n\n\t\tisSignalGetter.add(newValue.get)\n\n\t\treturn newValue\n\t} else if (kind === 'getter' || kind === 'setter') {\n\t\tconst getOrSet = value as Function\n\t\tconst initialValue = Undefined\n\n\t\tif (!Object.hasOwn(metadata, 'classySolid_getterSetterSignals')) metadata.classySolid_getterSetterSignals = {}\n\t\tconst signalsStorages = metadata.classySolid_getterSetterSignals!\n\n\t\tlet signalStorage = signalsStorages[name]\n\t\tif (!signalStorage) signalsStorages[name] = signalStorage = new WeakMap<object, SignalFunction<unknown>>()\n\n\t\tif (!Object.hasOwn(metadata, 'classySolid_getterSetterPairCounts')) metadata.classySolid_getterSetterPairCounts = {}\n\t\tconst pairs = metadata.classySolid_getterSetterPairCounts!\n\n\t\t// Show a helpful error in case someone forgets to decorate both a getter and setter.\n\t\tqueueMicrotask(() => {\n\t\t\tqueueMicrotask(() => delete metadata.classySolid_getterSetterPairCounts)\n\t\t\tconst missing = pairs[name] !== 2\n\t\t\tif (missing) throw new MissingSignalDecoratorError(name)\n\t\t})\n\n\t\tif (kind === 'getter') {\n\t\t\tpairs[name] ??= 0\n\t\t\tpairs[name]++\n\n\t\t\tconst newGetter = function (this: object): unknown {\n\t\t\t\tgetSignal__(this, signalStorage, initialValue)()\n\t\t\t\treturn getOrSet.call(this)\n\t\t\t}\n\n\t\t\tisSignalGetter.add(newGetter)\n\n\t\t\treturn newGetter\n\t\t} else {\n\t\t\tpairs[name] ??= 0\n\t\t\tpairs[name]++\n\n\t\t\tconst newSetter = function (this: object, newValue: unknown) {\n\t\t\t\t// batch, for example in case setter calls super setter, to\n\t\t\t\t// avoid multiple effect runs on a single property set.\n\t\t\t\tbatch(() => {\n\t\t\t\t\tgetOrSet.call(this, newValue)\n\t\t\t\t\ttrackPropSetAtLeastOnce__(this, name)\n\n\t\t\t\t\tconst s = getSignal__(this, signalStorage, initialValue)\n\t\t\t\t\ts(typeof newValue === 'function' ? () => newValue : newValue)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn newSetter\n\t\t}\n\t}\n}\n\nclass MissingSignalDecoratorError extends Error {\n\tconstructor(prop: PropertyKey) {\n\t\tsuper(\n\t\t\t`Missing @signal decorator on setter or getter for property \"${String(\n\t\t\t\tprop,\n\t\t\t)}\". The @signal decorator will only work on a getter/setter pair with *both* getter and setter decorated with @signal.`,\n\t\t)\n\t}\n}\n\nclass InvalidSignalDecoratorError extends Error {\n\tconstructor() {\n\t\tsuper('The @signal decorator is only for use on fields, getters, setters, and auto accessors.')\n\t}\n}\n"],"mappings":"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","ignoreList":[]}