{"version":3,"file":"untracked.js","names":["getListener","untrack","untracked","value","context","kind","TypeError","Class","ReactiveDecorator","constructor","args","instance","Reflect","construct","new","target"],"sources":["../../src/decorators/untracked.ts"],"sourcesContent":["import type {AnyConstructor} from 'lowclass/dist/Constructor.js'\nimport {getListener, untrack} from 'solid-js'\nimport './metadata-shim.js'\n\n/**\n * A decorator that makes a class's contructor untracked.\n *\n * Sometimes, not typically, you may want to ensure that when a class is\n * instantiated, any signal reads that happen during the constructor do not\n * track those reads.\n *\n * Normally you do not need to read signals during construction, but if you do,\n * you should use `@untracked` to avoid accidentally creating dependencies on\n * those signals for any effects that instantiate the class (therefore avoiding\n * infinite loops).\n *\n * Example:\n *\n * ```ts\n * import {untracked, signal} from \"classy-solid\";\n * import {createEffect} from \"solid-js\";\n *\n * ⁣@untracked\n * class Example {\n *   ⁣@signal count = 0;\n *\n *   constructor() {\n *     this.count = this.count + 1; // does not track .count signal read in any outer effect.\n *   }\n * }\n *\n * createEffect(() => {\n *   // This does not track .count, so this effect will not re-run when .count changes.\n *   // If this did track .count, an infinite loop would happen.\n *   const example = new Example();\n *\n *   createEffect(() => {\n *     // This inner effect tracks .count, so it will re-run (independent of the\n *     // outer effect) when .count changes.\n *     console.log(example.count);\n *   });\n * });\n * ```\n *\n * This can also be called manually without decorators:\n *\n * ```ts\n * import {untracked} from \"classy-solid\";\n *\n * const Example = untracked(\n *   class {\n *     count = 0;\n *\n *     constructor() {\n *       this.count = this.count + 1; // does not track .count signal read in any outer effect.\n *     }\n *   }\n * )\n *\n * // ...same usage as above...\n * ```\n */\nexport function untracked(value: AnyConstructor, context: ClassDecoratorContext | undefined): any {\n\t// context may be undefined when unsing untracked() without decorators\n\tif (typeof value !== 'function' || (context && context.kind !== 'class'))\n\t\tthrow new TypeError('The @untracked decorator is only for use on classes.')\n\n\tconst Class = value\n\n\tclass ReactiveDecorator extends Class {\n\t\tconstructor(...args: any[]) {\n\t\t\tlet instance!: ReactiveDecorator\n\n\t\t\t// Ensure that if we're in an effect that `new`ing a class does not\n\t\t\t// track signal reads, otherwise we'll get into an infinite loop. If\n\t\t\t// someone want to trigger an effect based on properties of the\n\t\t\t// `new`ed instance, they can explicitly read the properties\n\t\t\t// themselves in the effect, making their intent clear.\n\t\t\tif (getListener()) untrack(() => (instance = Reflect.construct(Class, args, new.target))) // super()\n\t\t\telse super(...args), (instance = this)\n\n\t\t\treturn instance\n\t\t}\n\t}\n\n\treturn ReactiveDecorator\n}\n"],"mappings":"AACA,SAAQA,WAAW,EAAEC,OAAO,QAAO,UAAU;AAC7C,OAAO,oBAAoB;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,KAAqB,EAAEC,OAA0C,EAAO;EACjG;EACA,IAAI,OAAOD,KAAK,KAAK,UAAU,IAAKC,OAAO,IAAIA,OAAO,CAACC,IAAI,KAAK,OAAQ,EACvE,MAAM,IAAIC,SAAS,CAAC,sDAAsD,CAAC;EAE5E,MAAMC,KAAK,GAAGJ,KAAK;EAEnB,MAAMK,iBAAiB,SAASD,KAAK,CAAC;IACrCE,WAAWA,CAAC,GAAGC,IAAW,EAAE;MAC3B,IAAIC,QAA4B;;MAEhC;MACA;MACA;MACA;MACA;MACA,IAAIX,WAAW,CAAC,CAAC,EAAEC,OAAO,CAAC,MAAOU,QAAQ,GAAGC,OAAO,CAACC,SAAS,CAACN,KAAK,EAAEG,IAAI,EAAEI,GAAG,CAACC,MAAM,CAAE,CAAC,EAAC;MAAA,KACrF,KAAK,CAAC,GAAGL,IAAI,CAAC,EAAGC,QAAQ,GAAG,IAAK;MAEtC,OAAOA,QAAQ;IAChB;EACD;EAEA,OAAOH,iBAAiB;AACzB","ignoreList":[]}