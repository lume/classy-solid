{"version":3,"file":"createDeferredEffect.test.js","names":["createRoot","createSignalFunction","createDeferredEffect","describe","it","count","foo","runCount","stop","_stop","expect","toBe","Promise","resolve"],"sources":["../../src/effects/createDeferredEffect.test.ts"],"sourcesContent":["import {createRoot} from 'solid-js'\nimport {createSignalFunction} from '../signals/createSignalFunction.js'\nimport {createDeferredEffect} from './createDeferredEffect.js'\n\ndescribe('classy-solid', () => {\n\tdescribe('createDeferredEffect()', () => {\n\t\tit('works', async () => {\n\t\t\tconst count = createSignalFunction(0)\n\t\t\tconst foo = createSignalFunction(0)\n\n\t\t\tlet runCount = 0\n\n\t\t\tconst stop = (() => {\n\t\t\t\tlet stop!: () => void\n\n\t\t\t\tcreateRoot(_stop => {\n\t\t\t\t\tstop = _stop\n\n\t\t\t\t\t// Runs once initially after the current root context just\n\t\t\t\t\t// like createEffect, then any time it re-runs due to a\n\t\t\t\t\t// change in a dependency, the re-run will be deferred in\n\t\t\t\t\t// the next microtask and will run only once (not once per\n\t\t\t\t\t// signal that changed)\n\t\t\t\t\tcreateDeferredEffect(() => {\n\t\t\t\t\t\tcount()\n\t\t\t\t\t\tfoo()\n\t\t\t\t\t\trunCount++\n\t\t\t\t\t})\n\t\t\t\t})\n\n\t\t\t\treturn stop\n\t\t\t})()\n\n\t\t\t// Queues the effect to run in the next microtask\n\t\t\tcount(1)\n\t\t\tcount(2)\n\t\t\tfoo(3)\n\n\t\t\t// Still 1 because the deferred effect didn't run yet, it will in the next microtask.\n\t\t\texpect(runCount).toBe(1)\n\n\t\t\tawait Promise.resolve()\n\n\t\t\t// It ran only once in the previous microtask (batched), not once per signal write.\n\t\t\texpect(runCount).toBe(2)\n\n\t\t\tcount(3)\n\t\t\tcount(4)\n\t\t\tfoo(5)\n\n\t\t\texpect(runCount).toBe(2)\n\n\t\t\tawait Promise.resolve()\n\n\t\t\texpect(runCount).toBe(3)\n\n\t\t\t// Stops the effect from re-running. It can now be garbage collected.\n\t\t\tstop()\n\n\t\t\tcount(3)\n\t\t\tcount(4)\n\t\t\tfoo(5)\n\n\t\t\texpect(runCount).toBe(3)\n\n\t\t\tawait Promise.resolve()\n\n\t\t\t// Still the same because it was stopped, so it didn't run in the\n\t\t\t// macrotask prior to the await.\n\t\t\texpect(runCount).toBe(3)\n\n\t\t\t// Double check just in case (the wrong implementation would make it\n\t\t\t// skip two microtasks before running).\n\t\t\tawait Promise.resolve()\n\t\t\texpect(runCount).toBe(3)\n\t\t})\n\t})\n})\n"],"mappings":"AAAA,SAAQA,UAAU,QAAO,UAAU;AACnC,SAAQC,oBAAoB,QAAO,oCAAoC;AACvE,SAAQC,oBAAoB,QAAO,2BAA2B;AAE9DC,QAAQ,CAAC,cAAc,EAAE,MAAM;EAC9BA,QAAQ,CAAC,wBAAwB,EAAE,MAAM;IACxCC,EAAE,CAAC,OAAO,EAAE,YAAY;MACvB,MAAMC,KAAK,GAAGJ,oBAAoB,CAAC,CAAC,CAAC;MACrC,MAAMK,GAAG,GAAGL,oBAAoB,CAAC,CAAC,CAAC;MAEnC,IAAIM,QAAQ,GAAG,CAAC;MAEhB,MAAMC,IAAI,GAAG,CAAC,MAAM;QACnB,IAAIA,IAAiB;QAErBR,UAAU,CAACS,KAAK,IAAI;UACnBD,IAAI,GAAGC,KAAK;;UAEZ;UACA;UACA;UACA;UACA;UACAP,oBAAoB,CAAC,MAAM;YAC1BG,KAAK,CAAC,CAAC;YACPC,GAAG,CAAC,CAAC;YACLC,QAAQ,EAAE;UACX,CAAC,CAAC;QACH,CAAC,CAAC;QAEF,OAAOC,IAAI;MACZ,CAAC,EAAE,CAAC;;MAEJ;MACAH,KAAK,CAAC,CAAC,CAAC;MACRA,KAAK,CAAC,CAAC,CAAC;MACRC,GAAG,CAAC,CAAC,CAAC;;MAEN;MACAI,MAAM,CAACH,QAAQ,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;MAExB,MAAMC,OAAO,CAACC,OAAO,CAAC,CAAC;;MAEvB;MACAH,MAAM,CAACH,QAAQ,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;MAExBN,KAAK,CAAC,CAAC,CAAC;MACRA,KAAK,CAAC,CAAC,CAAC;MACRC,GAAG,CAAC,CAAC,CAAC;MAENI,MAAM,CAACH,QAAQ,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;MAExB,MAAMC,OAAO,CAACC,OAAO,CAAC,CAAC;MAEvBH,MAAM,CAACH,QAAQ,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;;MAExB;MACAH,IAAI,CAAC,CAAC;MAENH,KAAK,CAAC,CAAC,CAAC;MACRA,KAAK,CAAC,CAAC,CAAC;MACRC,GAAG,CAAC,CAAC,CAAC;MAENI,MAAM,CAACH,QAAQ,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;MAExB,MAAMC,OAAO,CAACC,OAAO,CAAC,CAAC;;MAEvB;MACA;MACAH,MAAM,CAACH,QAAQ,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;;MAExB;MACA;MACA,MAAMC,OAAO,CAACC,OAAO,CAAC,CAAC;MACvBH,MAAM,CAACH,QAAQ,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;IACzB,CAAC,CAAC;EACH,CAAC,CAAC;AACH,CAAC,CAAC","ignoreList":[]}