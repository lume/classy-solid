(()=>{var __webpack_modules__={764:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";var _utils_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(773),__WEBPACK_DEFAULT_EXPORT__=newless,supportsSpread=isSyntaxSupported("Object(...[{}])"),supportsClass=isSyntaxSupported("class Test {}"),supportsNewTarget=isSyntaxSupported("new.target"),TRUE_CONSTRUCTOR=Symbol?Symbol("trueConstructor"):"__newlessTrueConstructor__",setPrototype=Object.setPrototypeOf||function(t,e){t.__proto__=e},construct=Reflect&&Reflect.construct||function(){if(supportsClass)return Function("constructor, args, target",`\n                'use strict';\n\n                if (arguments.length === 3 && typeof target !== 'function')\n                    throw new TypeError(target + ' is not a constructor');\n\n                target = target || constructor;\n\n                // extend target so the right prototype is constructed (or nearly the\n                // right one; ideally we'd do instantiator.prototype = target.prototype,\n                // but a class's prototype property is not writable)\n                class instantiator extends target {};\n                // but ensure the *logic* is 'constructor' for ES2015-compliant engines\n                Object.setPrototypeOf(instantiator, constructor);\n                // ...and for Safari 9\n                instantiator.prototype.constructor = constructor;\n\n                // The spread operator is *dramatically faster, so use it if we can:\n                // http://jsperf.com/new-via-spread-vs-dynamic-function/4\n                ${supportsSpread?"\n\n                    var value = new instantiator(...([].slice.call(args)));\n\n                ":"\n\n                    // otherwise, create a dynamic function in order to use 'new'\n                    // Note using 'function.bind' would be simpler, but is much slower:\n                    // http://jsperf.com/new-operator-with-dynamic-function-vs-bind\n                    var argList = '';\n                    for (var i = 0, len = args.length; i < len; i++) {\n                    if (i > 0) argList += ',';\n                    argList += 'args[' + i + ']';\n                    }\n                    var constructCall = Function('constructor, args',\n                    'return new constructor( ' + argList + ' );'\n                    );\n                    var value = constructCall(constructor, args);\n\n                    args = Array.prototype.slice.call(args);\n                    args = [null].concat(args);\n                    var value = new constructor.bind.apply(constructor, args);\n\n                "}\n\n                // fix up the prototype so it matches the intended one, not one who's\n                // prototype is the intended one :P\n                Object.setPrototypeOf(value, target.prototype);\n                return value;\n            `);var t=function(){};return function(e,n,r){if(3===arguments.length&&"function"!=typeof r)throw new TypeError(r+" is not a constructor");t.prototype=(r||e).prototype;var o=new t,s=e.apply(o,n);return"object"==typeof s&&s?(s.__proto__=(r||e).prototype,s):o}}(),SKIP_PROPERTIES=["arguments","caller","length","name","prototype"];function copyProperties(t,e){if(Object.getOwnPropertyNames&&Object.defineProperty){var n=Object.getOwnPropertyNames(t);Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(t)));for(var r=n.length-1;r>=0;r--)-1===SKIP_PROPERTIES.indexOf(n[r])&&Object.defineProperty(e,n[r],Object.getOwnPropertyDescriptor(t,n[r]))}else for(var o in t)e[o]=t[o]}function newless(constructor){var name=constructor.name,usesClassSyntax="class"===constructor.toString().substr(0,5),requiresNew=!!usesClassSyntax||null,newlessConstructor=(()=>function(){if(!requiresNew&&this instanceof newlessConstructor){if(!1===requiresNew){const t=constructor.apply(this,arguments);return"object"==typeof t&&t||this}try{requiresNew=!1;const t=constructor.apply(this,arguments);return"object"==typeof t&&t||this}catch(t){if(!(t instanceof TypeError&&(/class constructor/i.test(t.message)||/use the 'new' operator/i.test(t.message))))throw t instanceof Error&&/Illegal constructor/i.test(t.message)&&Object.create(constructor.prototype)instanceof Node&&console.error(`The following error can happen if a Custom Element is called\nwith 'new' before being defined. The constructor was ${constructor.name}: `,constructor),t;requiresNew=!0}}var newTarget,hasNewTarget=!1;supportsNewTarget&&(eval("newTarget = new.target"),newTarget&&(hasNewTarget=!0)),supportsNewTarget&&hasNewTarget||(newTarget=this instanceof newlessConstructor?this.constructor:constructor);const returnValue=construct(constructor,arguments,newTarget);return this instanceof newlessConstructor&&setPrototype(this,returnValue),returnValue})();if(name){const t=(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.Sh)(newlessConstructor);newlessConstructor=Function("constructor, construct, setPrototype, requiresNew, supportsNewTarget",`\n      var newlessConstructor = function ${name}() { ${t} };\n      return newlessConstructor\n    `)(constructor,construct,setPrototype,requiresNew,supportsNewTarget)}return constructor.length&&(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.q$)(newlessConstructor,"length",{value:constructor.length}),newlessConstructor.prototype=Object.create(constructor.prototype),newlessConstructor.prototype.constructor=newlessConstructor,constructor.prototype.constructor=constructor,newlessConstructor[TRUE_CONSTRUCTOR]=constructor,copyProperties(constructor,newlessConstructor),setPrototype(newlessConstructor,constructor),newlessConstructor}function isSyntaxSupported(t,e=!0){try{return!!Function("",(e?"'use strict';":"")+t)}catch(t){return!1}}},773:(t,e,n)=>{"use strict";function r(t){const e=t.toString().split("\n");return e.shift(),e.pop(),e.join("\n")}n.d(e,{Sh:()=>r,ld:()=>c,q$:()=>s,v_:()=>u});const o={enumerable:!0,configurable:!0};function s(t,e,n,r=!1){n=function(t,e){if(("get"in e||"set"in e)&&("value"in e||"writable"in e))throw new TypeError("cannot specify both accessors and a value or writable attribute");return t&&("get"in e||"set"in e?(delete t.value,delete t.writable):("value"in e||"writable"in e)&&(delete t.get,delete t.set)),{...o,...t,...e}}(r?c(t,e):Object.getOwnPropertyDescriptor(t,e),n),Object.defineProperty(t,e,n)}function c(t,e){let n,r=t;for(;r;){if(n=Object.getOwnPropertyDescriptor(r,e),n)return n.owner=r,n;r=r.__proto__}}function u(t){return t}}},__webpack_module_cache__={};function __webpack_require__(t){var e=__webpack_module_cache__[t];if(void 0!==e)return e.exports;var n=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t](n,n.exports,__webpack_require__),n.exports}__webpack_require__.d=(t,e)=>{for(var n in e)__webpack_require__.o(e,n)&&!__webpack_require__.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},__webpack_require__.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),__webpack_require__.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var __webpack_exports__={};(()=>{"use strict";var t;__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{component:()=>V,createDeferredEffect:()=>W,createSignal:()=>X,createSignalFunction:()=>z,createSignalObject:()=>G,getCreateSignalAccessor:()=>Z,getKey:()=>st,getPropsToSignalify:()=>ct,reactive:()=>_t,resetPropsToSignalify:()=>ut,signal:()=>at,signalify:()=>J,version:()=>dt}),function(t){t.PROXIES_ON_INSTANCE_AND_PROTOTYPE="PROXIES_ON_INSTANCE_AND_PROTOTYPE",t.PROXIES_ON_PROTOTYPE="PROXIES_ON_PROTOTYPE",t.PROXY_AFTER_INSTANCE_AND_PROTOTYPE="PROXY_AFTER_INSTANCE_AND_PROTOTYPE"}(t||(t={})),t.PROXIES_ON_INSTANCE_AND_PROTOTYPE;new WeakMap;__webpack_require__(764);var e=__webpack_require__(773);const n={context:void 0,registry:void 0};const r=Symbol("solid-proxy"),o=Symbol("solid-track"),s=(Symbol("solid-dev-component"),{equals:(t,e)=>t===e});let c=N;const u={owned:null,cleanups:null,context:null,owner:null};var a=null;let i=null,l=null,p=null,f=null,_=0;const[d,w]=h(!1);function h(t,e){const n={value:t,observers:null,observerSlots:null,comparator:(e=e?Object.assign({},s,e):s).equals||void 0};return[m.bind(n),t=>("function"==typeof t&&(t=i&&i.running&&i.sources.has(n)?t(n.tValue):t(n.value)),P(n,t))]}function g(t,e,n){c=j;const r=k(t,e,!1,1);n&&n.render||(r.user=!0),f?f.push(r):E(r)}function y(t,e,n){n=n?Object.assign({},s,n):s;const r=k(t,e,!0,0);return r.observers=null,r.observerSlots=null,r.comparator=n.equals||void 0,E(r),m.bind(r)}function b(t){if(null===l)return t();const e=l;l=null;try{return t()}finally{l=e}}function v(t){return null===a||(null===a.cleanups?a.cleanups=[t]:a.cleanups.push(t)),t}function S(){return a}function O(t){const e=y(t),n=y((()=>D(e())));return n.toArray=()=>{const t=n();return Array.isArray(t)?t:null!=t?[t]:[]},n}function m(){const t=i&&i.running;if(this.sources&&(t?this.tState:this.state))if(1===(t?this.tState:this.state))E(this);else{const t=p;p=null,C((()=>x(this)),!1),p=t}if(l){const t=this.observers?this.observers.length:0;l.sources?(l.sources.push(this),l.sourceSlots.push(t)):(l.sources=[this],l.sourceSlots=[t]),this.observers?(this.observers.push(l),this.observerSlots.push(l.sources.length-1)):(this.observers=[l],this.observerSlots=[l.sources.length-1])}return t&&i.sources.has(this)?this.tValue:this.value}function P(t,e,n){let r=i&&i.running&&i.sources.has(t)?t.tValue:t.value;if(!t.comparator||!t.comparator(r,e)){if(i){const r=i.running;(r||!n&&i.sources.has(t))&&(i.sources.add(t),t.tValue=e),r||(t.value=e)}else t.value=e;t.observers&&t.observers.length&&C((()=>{for(let e=0;e<t.observers.length;e+=1){const n=t.observers[e],r=i&&i.running;r&&i.disposed.has(n)||((r?n.tState:n.state)||(n.pure?p.push(n):f.push(n),n.observers&&R(n)),r?n.tState=1:n.state=1)}if(p.length>1e6)throw p=[],new Error}),!1)}return e}function E(t){if(!t.fn)return;q(t);const e=a,n=l,r=_;l=a=t,T(t,i&&i.running&&i.sources.has(t)?t.tValue:t.value,r),i&&!i.running&&i.sources.has(t)&&queueMicrotask((()=>{C((()=>{i&&(i.running=!0),l=a=t,T(t,t.tValue,r),l=a=null}),!1)})),l=n,a=e}function T(t,e,n){let r;try{r=t.fn(e)}catch(e){return t.pure&&(i&&i.running?(t.tState=1,t.tOwned&&t.tOwned.forEach(q),t.tOwned=void 0):(t.state=1,t.owned&&t.owned.forEach(q),t.owned=null)),t.updatedAt=n+1,I(e)}(!t.updatedAt||t.updatedAt<=n)&&(null!=t.updatedAt&&"observers"in t?P(t,r,!0):i&&i.running&&t.pure?(i.sources.add(t),t.tValue=r):t.value=r,t.updatedAt=n)}function k(t,e,n,r=1,o){const s={fn:t,state:r,updatedAt:null,owned:null,sources:null,sourceSlots:null,cleanups:null,value:e,owner:a,context:a?a.context:null,pure:n};return i&&i.running&&(s.state=0,s.tState=r),null===a||a!==u&&(i&&i.running&&a.pure?a.tOwned?a.tOwned.push(s):a.tOwned=[s]:a.owned?a.owned.push(s):a.owned=[s]),s}function A(t){const e=i&&i.running;if(0===(e?t.tState:t.state))return;if(2===(e?t.tState:t.state))return x(t);if(t.suspense&&b(t.suspense.inFallback))return t.suspense.effects.push(t);const n=[t];for(;(t=t.owner)&&(!t.updatedAt||t.updatedAt<_);){if(e&&i.disposed.has(t))return;(e?t.tState:t.state)&&n.push(t)}for(let r=n.length-1;r>=0;r--){if(t=n[r],e){let e=t,o=n[r+1];for(;(e=e.owner)&&e!==o;)if(i.disposed.has(e))return}if(1===(e?t.tState:t.state))E(t);else if(2===(e?t.tState:t.state)){const e=p;p=null,C((()=>x(t,n[0])),!1),p=e}}}function C(t,e){if(p)return t();let n=!1;e||(p=[]),f?n=!0:f=[],_++;try{const e=t();return function(t){if(p&&(N(p),p=null),t)return;let e;if(i)if(i.promises.size||i.queue.size){if(i.running)return i.running=!1,i.effects.push.apply(i.effects,f),f=null,void w(!0)}else{const t=i.sources,n=i.disposed;f.push.apply(f,i.effects),e=i.resolve;for(const t of f)"tState"in t&&(t.state=t.tState),delete t.tState;i=null,C((()=>{for(const t of n)q(t);for(const e of t){if(e.value=e.tValue,e.owned)for(let t=0,n=e.owned.length;t<n;t++)q(e.owned[t]);e.tOwned&&(e.owned=e.tOwned),delete e.tValue,delete e.tOwned,e.tState=0}w(!1)}),!1)}const n=f;f=null,n.length&&C((()=>c(n)),!1),e&&e()}(n),e}catch(t){n||(f=null),p=null,I(t)}}function N(t){for(let e=0;e<t.length;e++)A(t[e])}function j(t){let e,r=0;for(e=0;e<t.length;e++){const n=t[e];n.user?t[r++]=n:A(n)}if(n.context){if(n.count)return n.effects||(n.effects=[]),void n.effects.push(...t.slice(0,r));n.effects&&(t=[...n.effects,...t],r+=n.effects.length,delete n.effects),n.context=o}var o;for(e=0;e<r;e++)A(t[e])}function x(t,e){const n=i&&i.running;n?t.tState=0:t.state=0;for(let r=0;r<t.sources.length;r+=1){const o=t.sources[r];if(o.sources){const t=n?o.tState:o.state;1===t?o!==e&&(!o.updatedAt||o.updatedAt<_)&&A(o):2===t&&x(o,e)}}}function R(t){const e=i&&i.running;for(let n=0;n<t.observers.length;n+=1){const r=t.observers[n];(e?r.tState:r.state)||(e?r.tState=2:r.state=2,r.pure?p.push(r):f.push(r),r.observers&&R(r))}}function q(t){let e;if(t.sources)for(;t.sources.length;){const e=t.sources.pop(),n=t.sourceSlots.pop(),r=e.observers;if(r&&r.length){const t=r.pop(),o=e.observerSlots.pop();n<r.length&&(t.sourceSlots[o]=n,r[n]=t,e.observerSlots[n]=o)}}if(i&&i.running&&t.pure){if(t.tOwned){for(e=t.tOwned.length-1;e>=0;e--)q(t.tOwned[e]);delete t.tOwned}M(t,!0)}else if(t.owned){for(e=t.owned.length-1;e>=0;e--)q(t.owned[e]);t.owned=null}if(t.cleanups){for(e=t.cleanups.length-1;e>=0;e--)t.cleanups[e]();t.cleanups=null}i&&i.running?t.tState=0:t.state=0}function M(t,e){if(e||(t.tState=0,i.disposed.add(t)),t.owned)for(let e=0;e<t.owned.length;e++)M(t.owned[e])}function I(t,e=a){const n=function(t){return t instanceof Error?t:new Error("string"==typeof t?t:"Unknown error",{cause:t})}(t);throw n}function D(t){if("function"==typeof t&&!t.length)return D(t());if(Array.isArray(t)){const e=[];for(let n=0;n<t.length;n++){const r=D(t[n]);Array.isArray(r)?e.push.apply(e,r):e.push(r)}return e}return t}function L(t,e){return function(e){let n;return function(r,o,s){const c=k((()=>n=b((()=>(a.context={...a.context,[t]:e.value},O((()=>e.children)))))),void 0,!1,1);E(c)}(),n}}function V(t,...n){const[r]=n;if("function"!=typeof t||r&&"class"!==r.kind)throw new Error("The @component decorator should only be used on a class.");const s=(0,e.v_)(t);return function(t){const e=new s,n=y((()=>(t[o],Object.keys(t))),[],{equals(t,e){if(t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n+=1)if(t[n]!==e[n])return!1;return!0}});var r;return g((()=>{for(const r of n())g((()=>{e[r]=t[r]}))})),e.onMount&&(r=()=>e.onMount?.(),g((()=>b(r)))),e.onCleanup&&v((()=>e.onCleanup?.())),e.template?.(t)??null}}Symbol("fallback"),function(t,e){const n=Symbol("context");L(n)}();const U=new Set;let $=!1;const F=new Map;let Y=()=>{},X=(t,e)=>{let[n,r]=h(t,e);return[()=>{if(!$)return n();let t=F.get(Y);return t||F.set(Y,t=new Set),t.add(r),n()},t=>{if(!$)return r(t);for(const[t,e]of F)for(const n of e)n===r&&(U.delete(t),U.add(t));return r(t)}]},K=!1;const W=(t,e,n)=>{let r=!0;g((e=>{if(r)return r=!1,Y=t,F.get(t)?.clear(),void t(e);if(U.add(t),$)return;if(K)return;K=!0;const n=S();queueMicrotask((()=>{n?function(t,e){const n=a,r=l;a=t,l=null;try{C(e,!0)}catch(t){I(t)}finally{a=n,l=r}}(n,B):B()}))}),e,n),S()&&v((()=>{F.delete(t),U.delete(t)}))};function B(){$=!0;for(const t of U)U.delete(t),W(t);$=!1,K=!1}function z(t,e){const[n,r]=h(t,e);return function(t){return 0===arguments.length?n():r(t)}}function G(t,e){const[n,r]=X(t,e);return{get:n,set:r}}const H=new WeakMap;function J(t,...e){const n=e.length?e:Object.keys(t).concat(Object.getOwnPropertySymbols(t));for(const e of n)tt(t,e);return t}let Q=!1;function Z(){if(Q)throw new Error('Export "createSignalAccessor" is internal to classy-solid only.');return Q=!0,tt}function tt(t,n,o=t[n]){if(H.get(t)?.has(n))return;if(t[r])return;let s,c,u=(0,e.ld)(t,n);if(u)if(s=u.get,c=u.set,s||c){if(!s||!c)return void console.warn(`The \`@signal\` decorator was used on an accessor named "${n.toString()}" which had a getter or a setter, but not both. Reactivity on accessors works only when accessors have both get and set. In this case the decorator does not do anything.`);delete u.get,delete u.set}else{if(o=u.value,!u.writable)return void console.warn(`The \`@signal\` decorator was used on a property named "${n.toString()}" that is not writable. Reactivity is not enabled for non-writable properties.`);delete u.value,delete u.writable}u={configurable:!0,enumerable:!0,...u,get:s?function(){return nt(this,n,o)[0](),s.call(this)}:function(){return nt(this,n,o)[0]()},set:c?function(t){c.call(this,t),this.__propsSetAtLeastOnce__||(this.__propsSetAtLeastOnce__=new Set),this.__propsSetAtLeastOnce__.add(n);const e=nt(this,n);"function"==typeof t?e[1]((()=>t)):e[1](t)}:function(t){this.__propsSetAtLeastOnce__||(this.__propsSetAtLeastOnce__=new Set),this.__propsSetAtLeastOnce__.add(n);const e=nt(this,n);"function"==typeof t?e[1]((()=>t)):e[1](t)}},Object.defineProperty(t,n,u),H.has(t)||H.set(t,new Set),H.get(t).add(n)}const et=new WeakMap;function nt(t,e,n){et.has(t)||et.set(t,new Map);let r=et.get(t).get(e);return r||(r=h(n,{equals:!1}),et.get(t)?.set(e,r),r)}let rt=new Map,ot=null;function st(){if(ot)throw new Error("Attempted use of classy-solid internals.");return ot=Symbol(),ot}function ct(t){if(t!==ot)throw new Error("Attempted use of classy-solid internals.");return rt}function ut(t){if(t!==ot)throw new Error("Attempted use of classy-solid internals.");rt=new Map}function at(...t){const[e,{kind:n,name:r,private:o,static:s}]=t,c=rt;if(o)throw new Error("@signal is not supported on private fields yet.");if(s)throw new Error("@signal is not supported on static fields yet.");if("field"===n)return c.set(r,{initialValue:void 0}),function(t){return c.get(r).initialValue=t,t};if("accessor"===n)throw new Error("@signal not supported on `accessor` fields yet.");if("getter"!==n&&"setter"!==n)throw new Error("The @signal decorator is only for use on fields, accessors, getters, and setters.");c.set(r,{initialValue:void 0}),function(t){it||(it=!0,queueMicrotask((()=>{if(it=!1,t===rt)throw new Error(`Stray @signal-decorated properties detected: ${Array.from(t.keys()).join(", ")}. Did you forget to use the \`@reactive\` decorator on a class that has properties decorated with \`@signal\`?`)})))}(c)}let it=!1;const lt=st(),pt=Z(),ft=Object.prototype.hasOwnProperty;function _t(...t){const[e,n]=t;if("function"!=typeof e||n&&"class"!==n.kind)throw new TypeError("The @reactive decorator is only for use on classes.");const r=e,o=ct(lt);return ut(lt),class extends r{constructor(...t){let e;l?b((()=>e=Reflect.construct(r,t,new.target))):(super(...t),e=this);for(const[t,{initialValue:n}]of o){if(!ft.call(e,t)&&!ft.call(r.prototype,t))throw new Error(`Property "${t.toString()}" not found on object. Did you forget to use the \`@reactive\` decorator on a class that has properties decorated with \`@signal\`?`);pt(e,t,n)}return e}}}const dt="0.2.3"})();var __webpack_export_target__=LUME="undefined"==typeof LUME?{}:LUME;for(var i in __webpack_exports__)__webpack_export_target__[i]=__webpack_exports__[i];__webpack_exports__.__esModule&&Object.defineProperty(__webpack_export_target__,"__esModule",{value:!0})})();
//# sourceMappingURL=global.js.map