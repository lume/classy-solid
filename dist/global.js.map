{"version":3,"file":"global.js","mappings":"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","sources":["webpack://LUME/../lowclass/src/native.ts","webpack://LUME/../lowclass/src/utils.ts","webpack://LUME/webpack/bootstrap","webpack://LUME/webpack/runtime/define property getters","webpack://LUME/webpack/runtime/hasOwnProperty shorthand","webpack://LUME/webpack/runtime/make namespace object","webpack://LUME/../lowclass/src/multiple.ts","webpack://LUME/../../node_modules/solid-js/dist/solid.js","webpack://LUME/./src/component.ts","webpack://LUME/./src/createDeferredEffect.ts","webpack://LUME/./src/createSignalFunction.ts","webpack://LUME/./src/createSignalObject.ts","webpack://LUME/./src/signalify.ts","webpack://LUME/./src/decorators/signal.ts","webpack://LUME/./src/decorators/reactive.ts","webpack://LUME/./src/index.ts"],"sourcesContent":["// borrowed from (and slightly modified) https://github.com/Mr0grog/newless\n// The newless license is BSD 3:\n\n// TODO no any types\n\n/*\n * Copyright (c) 2013-2016, Rob Brackett\n * Copyright (c) 2018, Joseph Orbegoso Pea\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport {getFunctionBody, setDescriptor, Constructor} from './utils.js'\n\nexport {newless as native}\n\nexport default newless\n\nvar supportsSpread = isSyntaxSupported('Object(...[{}])')\nvar supportsClass = isSyntaxSupported('class Test {}')\nvar supportsNewTarget = isSyntaxSupported('new.target')\n\n// Used to track the original wrapped constructor on a newless instance\nvar TRUE_CONSTRUCTOR = Symbol ? Symbol('trueConstructor') : '__newlessTrueConstructor__'\n\nvar setPrototype =\n\tObject.setPrototypeOf ||\n\tfunction setPrototypeOf(object, newPrototype) {\n\t\tobject.__proto__ = newPrototype\n\t}\n\n// Polyfill for Reflect.construct\nvar construct =\n\t(Reflect && Reflect.construct) ||\n\t(function () {\n\t\tif (supportsClass) {\n\t\t\treturn Function(\n\t\t\t\t'constructor, args, target',\n\t\t\t\t`\n                'use strict';\n\n                if (arguments.length === 3 && typeof target !== 'function')\n                    throw new TypeError(target + ' is not a constructor');\n\n                target = target || constructor;\n\n                // extend target so the right prototype is constructed (or nearly the\n                // right one; ideally we'd do instantiator.prototype = target.prototype,\n                // but a class's prototype property is not writable)\n                class instantiator extends target {};\n                // but ensure the *logic* is 'constructor' for ES2015-compliant engines\n                Object.setPrototypeOf(instantiator, constructor);\n                // ...and for Safari 9\n                instantiator.prototype.constructor = constructor;\n\n                // The spread operator is *dramatically faster, so use it if we can:\n                // http://jsperf.com/new-via-spread-vs-dynamic-function/4\n                ${\n\t\t\t\t\tsupportsSpread\n\t\t\t\t\t\t? `\n\n                    var value = new instantiator(...([].slice.call(args)));\n\n                `\n\t\t\t\t\t\t: `\n\n                    // otherwise, create a dynamic function in order to use 'new'\n                    // Note using 'function.bind' would be simpler, but is much slower:\n                    // http://jsperf.com/new-operator-with-dynamic-function-vs-bind\n                    var argList = '';\n                    for (var i = 0, len = args.length; i < len; i++) {\n                    if (i > 0) argList += ',';\n                    argList += 'args[' + i + ']';\n                    }\n                    var constructCall = Function('constructor, args',\n                    'return new constructor( ' + argList + ' );'\n                    );\n                    var value = constructCall(constructor, args);\n\n                    args = Array.prototype.slice.call(args);\n                    args = [null].concat(args);\n                    var value = new constructor.bind.apply(constructor, args);\n\n                `\n\t\t\t\t}\n\n                // fix up the prototype so it matches the intended one, not one who's\n                // prototype is the intended one :P\n                Object.setPrototypeOf(value, target.prototype);\n                return value;\n            `,\n\t\t\t)\n\n\t\t\t//return Function(\"constructor, args, newTarget\", `\n\t\t\t//  'use strict';\n\n\t\t\t//  if (arguments.length === 3 && typeof newTarget === undefined)\n\t\t\t//    throw new TypeError('undefined is not a constructor');\n\n\t\t\t//  newTarget = newTarget || constructor;\n\n\t\t\t//  ${ supportsSpread ? `\n\n\t\t\t//    var value = new constructor(...([].slice.call(args)));\n\n\t\t\t//  `:`\n\n\t\t\t//    args = Array.prototype.slice.call(args);\n\t\t\t//    args = [null].concat(args);\n\t\t\t//    var value = new constructor.bind.apply(constructor, args);\n\n\t\t\t//  `}\n\n\t\t\t//  Object.setPrototypeOf(value, newTarget.prototype);\n\t\t\t//  return value;\n\t\t\t//`);\n\t\t} else {\n\t\t\tvar instantiator = function () {} as any\n\t\t\treturn function construct(constructor: any, args: any, target: any) {\n\t\t\t\tif (arguments.length === 3 && typeof target !== 'function')\n\t\t\t\t\tthrow new TypeError(target + ' is not a constructor')\n\t\t\t\tinstantiator.prototype = (target || constructor).prototype\n\t\t\t\tvar instance = new instantiator()\n\t\t\t\tvar value = constructor.apply(instance, args)\n\t\t\t\tif (typeof value === 'object' && value) {\n\t\t\t\t\t// we can do better if __proto__ is available (in some ES5 environments)\n\t\t\t\t\tvalue.__proto__ = (target || constructor).prototype\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn instance\n\t\t\t}\n\t\t}\n\t})()\n\n// ES2015 class methods are non-enumerable; we need a helper for copying them.\nvar SKIP_PROPERTIES: (string | symbol)[] = ['arguments', 'caller', 'length', 'name', 'prototype']\nfunction copyProperties(source: any, destination: any) {\n\tif (Object.getOwnPropertyNames && Object.defineProperty) {\n\t\tvar properties: (string | symbol)[] = Object.getOwnPropertyNames(source)\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tproperties = properties.concat(Object.getOwnPropertySymbols(source))\n\t\t}\n\t\tfor (var i = properties.length - 1; i >= 0; i--) {\n\t\t\tif (SKIP_PROPERTIES.indexOf(properties[i]) === -1) {\n\t\t\t\tObject.defineProperty(\n\t\t\t\t\tdestination,\n\t\t\t\t\tproperties[i],\n\t\t\t\t\tObject.getOwnPropertyDescriptor(source, properties[i])!,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var property in source) {\n\t\t\tdestination[property] = source[property]\n\t\t}\n\t}\n}\n\ntype FuncLikeCtor<T, S = {}> = {\n\t(): T\n\tnew (): T\n} & S\n\nfunction newless<T extends Constructor>(constructor: T): FuncLikeCtor<InstanceType<T>, T> {\n\tvar name = constructor.name\n\n\t// V8 and newer versions of JSCore return the full class declaration from\n\t// `toString()`, which lets us be a little smarter and more performant\n\t// about what to do, since we know we are dealing with a \"class\". Note,\n\t// however, not all engines do this. This could be false and the constructor\n\t// might still use class syntax.\n\tvar usesClassSyntax = constructor.toString().substr(0, 5) === 'class'\n\n\tvar requiresNew = usesClassSyntax ? true : null\n\n\tvar newlessConstructor: CtorWithLength = (() =>\n\t\tfunction (this: any) {\n\t\t\t// If called with an already valid 'this', preserve that 'this' value\n\t\t\t// in the super-type's constructor whenever possible. With function\n\t\t\t// constructors (as opposed to class constructors), it's possible to\n\t\t\t// alter the instance before calling the super constructor--so it's\n\t\t\t// important to preserve that instance if at all possible.\n\t\t\tif (!requiresNew && this instanceof newlessConstructor) {\n\t\t\t\t// requiresNew = 'false' indicates we know the 'new' operator isn't\n\t\t\t\t// necessary for this constructor, but 'null' indicates uncertainty,\n\t\t\t\t// so the call needs to handle potential errors the first time in\n\t\t\t\t// order to determine whether 'new' is definitely required.\n\t\t\t\tif (requiresNew === false) {\n\t\t\t\t\tconst returnValue = constructor.apply(this, arguments as any)\n\t\t\t\t\treturn (typeof returnValue === 'object' && returnValue) || this\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\trequiresNew = false\n\t\t\t\t\tconst returnValue = constructor.apply(this, arguments as any)\n\t\t\t\t\treturn (typeof returnValue === 'object' && returnValue) || this\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Do our best to only capture errors triggred by class syntax.\n\t\t\t\t\t// Unfortunately, there's no special error type for this and the\n\t\t\t\t\t// message is non-standard, so this is the best check we can do.\n\t\t\t\t\tif (\n\t\t\t\t\t\terror instanceof TypeError &&\n\t\t\t\t\t\t(/class constructor/i.test(error.message) || /use the 'new' operator/i.test(error.message)) // Custom Elements in Chrome\n\t\t\t\t\t\t// TODO: there might be other error messages we need to catch,\n\t\t\t\t\t\t// depending on engine and use case. We need to test in all browsers\n\t\t\t\t\t) {\n\t\t\t\t\t\t// mark this constructor as requiring 'new' for next time\n\t\t\t\t\t\trequiresNew = true\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terror instanceof Error &&\n\t\t\t\t\t\t\t/Illegal constructor/i.test(error.message) &&\n\t\t\t\t\t\t\tObject.create(constructor.prototype) instanceof Node\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t`The following error can happen if a Custom Element is called\nwith 'new' before being defined. The constructor was ${constructor.name}: `,\n\t\t\t\t\t\t\t\tconstructor,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// make a reasonably good replacement for 'new.target' which is a\n\t\t\t// syntax error in older engines\n\t\t\tvar newTarget\n\t\t\tvar hasNewTarget = false\n\t\t\tif (supportsNewTarget) {\n\t\t\t\teval('newTarget = new.target')\n\t\t\t\tif (newTarget) hasNewTarget = true\n\t\t\t}\n\t\t\tif (!supportsNewTarget || !hasNewTarget) {\n\t\t\t\tnewTarget = this instanceof newlessConstructor ? this.constructor : constructor\n\t\t\t}\n\t\t\tconst returnValue = construct(constructor, arguments, newTarget)\n\t\t\t// best effort to make things easy for functions inheriting from classes\n\t\t\tif (this instanceof newlessConstructor) {\n\t\t\t\tsetPrototype(this, returnValue)\n\t\t\t}\n\t\t\treturn returnValue\n\t\t})() as unknown as CtorWithLength\n\n\tif (name) {\n\t\tconst code = getFunctionBody(newlessConstructor)\n\n\t\tnewlessConstructor = Function(\n\t\t\t'constructor, construct, setPrototype, requiresNew, supportsNewTarget',\n\t\t\t`\n      var newlessConstructor = function ${name}() { ${code} };\n      return newlessConstructor\n    `,\n\t\t)(constructor, construct, setPrototype, requiresNew, supportsNewTarget)\n\t}\n\n\t// copy the `.length` value to the newless constructor\n\tif (constructor.length) {\n\t\t// length is not writable, only configurable, therefore the value\n\t\t// has to be set with a descriptor update\n\t\tsetDescriptor(newlessConstructor, 'length', {\n\t\t\tvalue: constructor.length,\n\t\t})\n\t}\n\n\tnewlessConstructor.prototype = Object.create(constructor.prototype)\n\tnewlessConstructor.prototype.constructor = newlessConstructor\n\n\t// NOTE: *usually* the below will already be true, but we ensure it here.\n\t// Safari 9 requires this for the 'super' keyword to work. Newer versions\n\t// of WebKit and other engines do not. Instead, they use the constructor's\n\t// prototype chain (which is correct by ES2015 spec) (see below).\n\tconstructor.prototype.constructor = constructor\n\n\t// for ES2015 classes, we need to make sure the constructor's prototype\n\t// is the super class's constructor. Further, optimize performance by\n\t// pointing at the actual constructor implementation instead of the\n\t// newless wrapper (in the case that it is wrapped by newless).\n\t;(newlessConstructor as any)[TRUE_CONSTRUCTOR] = constructor\n\n\tcopyProperties(constructor, newlessConstructor)\n\tsetPrototype(newlessConstructor, constructor)\n\n\treturn newlessConstructor as FuncLikeCtor<InstanceType<T>, T>\n}\n\n// Test whether a given syntax is supported\nfunction isSyntaxSupported(example: string, useStrict = true): boolean {\n\ttry {\n\t\treturn !!Function('', (useStrict ? \"'use strict';\" : '') + example)\n\t} catch (error) {\n\t\treturn false\n\t}\n}\n\ntype CtorWithLength = Constructor<\n\tobject,\n\tany[],\n\t{\n\t\tlength: number\n\t}\n>\n","// TODO no any\n\nexport class WeakTwoWayMap {\n\tm = new WeakMap()\n\tset(a: Object, b: Object) {\n\t\tthis.m.set(a, b)\n\t\tthis.m.set(b, a)\n\t}\n\tget(item: Object) {\n\t\treturn this.m.get(item)\n\t}\n\thas(item: Object) {\n\t\treturn this.m.has(item)\n\t}\n}\n\n// assumes the function opening, body, and closing are on separate lines\nexport function getFunctionBody(fn: Function): string {\n\tconst code = fn.toString().split('\\n')\n\tcode.shift() // remove opening line (function() {)\n\tcode.pop() // remove closing line (})\n\treturn code.join('\\n')\n}\n\nconst descriptorDefaults = {\n\tenumerable: true,\n\tconfigurable: true,\n}\n\n// makes it easier and less verbose to work with descriptors\nexport function setDescriptor<T extends {}>(\n\tobj: T,\n\tkey: keyof T,\n\tnewDescriptor: PropertyDescriptor,\n\tinherited = false,\n): void {\n\tlet currentDescriptor = inherited ? getInheritedDescriptor(obj, key) : Object.getOwnPropertyDescriptor(obj, key)\n\n\tnewDescriptor = overrideDescriptor(currentDescriptor, newDescriptor)\n\tObject.defineProperty(obj, key, newDescriptor)\n}\n\nexport function setDescriptors(obj: Object, newDescriptors: Record<string, PropertyDescriptor>): void {\n\tlet newDescriptor\n\tlet currentDescriptor\n\tconst currentDescriptors = Object.getOwnPropertyDescriptors(obj)\n\n\tfor (const key in newDescriptors) {\n\t\tnewDescriptor = newDescriptors[key]\n\t\tcurrentDescriptor = currentDescriptors[key]\n\t\tnewDescriptors[key] = overrideDescriptor(currentDescriptor, newDescriptor)\n\t}\n\n\tObject.defineProperties(obj, newDescriptors)\n}\n\nfunction overrideDescriptor(\n\toldDescriptor: PropertyDescriptor | undefined,\n\tnewDescriptor: PropertyDescriptor,\n): PropertyDescriptor {\n\tif (\n\t\t('get' in newDescriptor || 'set' in newDescriptor) &&\n\t\t('value' in newDescriptor || 'writable' in newDescriptor)\n\t) {\n\t\tthrow new TypeError('cannot specify both accessors and a value or writable attribute')\n\t}\n\n\tif (oldDescriptor) {\n\t\tif ('get' in newDescriptor || 'set' in newDescriptor) {\n\t\t\tdelete oldDescriptor.value\n\t\t\tdelete oldDescriptor.writable\n\t\t} else if ('value' in newDescriptor || 'writable' in newDescriptor) {\n\t\t\tdelete oldDescriptor.get\n\t\t\tdelete oldDescriptor.set\n\t\t}\n\t}\n\n\treturn {...descriptorDefaults, ...oldDescriptor, ...newDescriptor}\n}\n\n// TODO use signature override\nexport function propertyIsAccessor<T extends Object | PropertyDescriptor>(\n\tobj: T,\n\tkey?: keyof T,\n\tinherited = true,\n): boolean {\n\tlet result = false\n\tlet descriptor: PropertyDescriptor | undefined\n\n\tif (arguments.length === 1) {\n\t\tdescriptor = obj\n\t} else {\n\t\tdescriptor = inherited ? getInheritedDescriptor(obj, key!) : Object.getOwnPropertyDescriptor(obj, key!)\n\t}\n\n\tif (descriptor && (descriptor.get || descriptor.set)) result = true\n\n\treturn result\n}\n\ninterface DescriptorWithOwner extends PropertyDescriptor {\n\towner: object\n}\n\nexport function getInheritedDescriptor<T extends object>(obj: T, key: keyof T): DescriptorWithOwner | undefined {\n\tlet currentProto = obj\n\tlet descriptor\n\n\twhile (currentProto) {\n\t\tdescriptor = Object.getOwnPropertyDescriptor(currentProto, key)\n\n\t\tif (descriptor) {\n\t\t\t;(descriptor as DescriptorWithOwner).owner = currentProto\n\t\t\treturn descriptor as DescriptorWithOwner\n\t\t}\n\n\t\tcurrentProto = (currentProto as any).__proto__\n\t}\n\n\treturn void 0\n}\n\nexport function getInheritedPropertyNames<T extends object>(obj: T): (keyof T)[] {\n\tlet currentProto = obj\n\tlet keys: (keyof T)[] = []\n\n\twhile (currentProto) {\n\t\tkeys = keys.concat(Object.getOwnPropertyNames(currentProto) as (keyof T)[])\n\t\tcurrentProto = (currentProto as any).__proto__\n\t}\n\n\t// remove duplicates\n\tkeys = Array.from(new Set(keys))\n\n\treturn keys\n}\n\nexport type Constructor<T = object, A extends any[] = any[], Static = {}> = (new (...a: A) => T) & Static\n\n// this is used for type casting in special cases, see the declaration file\nexport function Constructor<T = object, Static = {}>(Ctor: Constructor<any>): Constructor<T> & Static {\n\treturn Ctor as unknown as Constructor<T> & Static\n}\n\n// check if an object has the given prototype in its chain\nexport function hasPrototype(obj: any, proto: any) {\n\tlet currentProto = obj.__proto__\n\n\tdo {\n\t\tif (proto === currentProto) return true\n\t\tcurrentProto = currentProto.__proto__\n\t} while (currentProto)\n\n\treturn false\n}\n\n// copy all properties (as descriptors) from source to destination\nexport function copyDescriptors(source: Object, destination: Object, mod?: any) {\n\tconst props = Object.getOwnPropertyNames(source)\n\tlet i = props.length\n\twhile (i--) {\n\t\tconst prop = props[i]\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(source, prop)\n\t\tif (mod) mod(descriptor)\n\t\tObject.defineProperty(destination, prop, descriptor!)\n\t}\n}\n\nexport function setDefaultPrototypeDescriptors(\n\tprototype: Object,\n\t{defaultClassDescriptor: {writable, enumerable, configurable}}: any,\n) {\n\tconst descriptors = Object.getOwnPropertyDescriptors(prototype)\n\tlet descriptor\n\n\tfor (const key in descriptors) {\n\t\tdescriptor = descriptors[key]\n\n\t\t// regular value\n\t\tif ('value' in descriptor || 'writable' in descriptor) {\n\t\t\tdescriptor.writable = writable\n\t\t}\n\n\t\t// accessor or regular value\n\t\tdescriptor.enumerable = enumerable\n\t\tdescriptor.configurable = configurable\n\t}\n\n\tsetDescriptors(prototype, descriptors)\n}\n\nexport function setDefaultStaticDescriptors(\n\tCtor: any,\n\t{defaultClassDescriptor: {writable, enumerable, configurable}}: any,\n\tstaticBlacklist?: (string | symbol)[],\n) {\n\tconst descriptors = Object.getOwnPropertyDescriptors(Ctor)\n\tlet descriptor\n\n\tfor (const key in descriptors) {\n\t\tif (staticBlacklist && staticBlacklist.includes(key)) {\n\t\t\tdelete descriptors[key]\n\t\t\tcontinue\n\t\t}\n\n\t\tdescriptor = descriptors[key]\n\n\t\t// regular value\n\t\tif ('value' in descriptor || 'writable' in descriptor) {\n\t\t\tdescriptor.writable = writable\n\t\t}\n\n\t\t// accessor or regular value\n\t\tdescriptor.enumerable = enumerable\n\t\tdescriptor.configurable = configurable\n\t}\n\n\tsetDescriptors(Ctor, descriptors)\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type {Constructor} from './utils.js'\n\n// --- TODO handle static inheritance. Nothing has been implemented with regards to\n// static inheritance yet.\n\n// --- TODO allow the subclass (f.e. the `Foo` in `class Foo extends multiple(One,\n// Two, Three) {}`) to call each super constructor (One, Two, and Three)\n// individually with specific arguments.\n\n// --- TODO Prevent duplicate classes in the \"prototype tree\". F.e. if someone calls\n// `multiple(One, Two, Three)`, and `Three` already includes `Two`, we can\n// discard the `Two` argument and perform the combination as if `multiple(One,\n// Three)` had been called.\n\n// --- TODO cache the results, so more than one call to `multiple(One, Two, Three)`\n// returns the same class reference as the first call.\n\n// --- TODO, allow the user to handle the diamond problem in some way other than\n// (\"property or method from the first class in the list wins\"). Perhaps require\n// the user to specify which method to call. For now, it simply calls the first\n// method in the order in which the classes were passed into multiple(). Look\n// here for ideas based on how different languages handle it:\n// https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\n\nenum ImplementationMethod {\n\tPROXIES_ON_INSTANCE_AND_PROTOTYPE = 'PROXIES_ON_INSTANCE_AND_PROTOTYPE',\n\tPROXIES_ON_PROTOTYPE = 'PROXIES_ON_PROTOTYPE',\n\n\t// TODO, This will be similar to PROXIES_ON_INSTANCE_AND_PROTOTYPE, but\n\t// instead of placing a proxy on the instance, place a Proxy as a direct\n\t// prototype of the instance. I think this should work with Custom Elements,\n\t// and unlike PROXIES_ON_PROTOTYPE, super calls won't access own properties\n\t// on the instance, but actually on the prototypes (test5 super access tests\n\t// fail with PROXIES_ON_PROTOTYPE method).\n\tPROXY_AFTER_INSTANCE_AND_PROTOTYPE = 'PROXY_AFTER_INSTANCE_AND_PROTOTYPE',\n}\n\ntype MultipleOptions = {\n\tmethod: ImplementationMethod\n}\n\nexport function makeMultipleHelper(options?: MultipleOptions) {\n\t/**\n\t * Mixes the given classes into a single class. This is useful for multiple\n\t * inheritance.\n\t *\n\t * @example\n\t * class Foo {}\n\t * class Bar {}\n\t * class Baz {}\n\t * class MyClass extends multiple(Foo, Bar, Baz) {}\n\t */\n\t//  ------------ method 1, define the `multiple()` signature with overrides. The\n\t//  upside is it is easy to understand, but the downside is that name collisions\n\t//  in properties cause the collided property type to be `never`. This would make\n\t//  it more difficult to provide solution for the diamond problem.\n\t//  ----------------\n\t// function multiple(): typeof Object\n\t// function multiple<T extends Constructor>(classes: T): T\n\t// function multiple<T extends Constructor[]>(...classes: T): Constructor<ConstructorUnionToInstanceTypeUnion<T[number]>>\n\t// function multiple(...classes: any): any {\n\t//\n\t//  ------------ method 2, define the signature of `multiple()` with a single\n\t//  signature. The upside is this picks the type of the first property\n\t//  encountered when property names collide amongst all the classes passed into\n\t//  `multiple()`, but the downside is the inner implementation may require\n\t//  casting, and this approach can also cause an infinite type recursion\n\t//  depending on the types used inside the implementation.\n\t//  ----------------\n\treturn function multiple<T extends Constructor[]>(...classes: T): CombinedClasses<T> {\n\t\tconst mode = (options && options.method) || ImplementationMethod.PROXIES_ON_INSTANCE_AND_PROTOTYPE\n\n\t\tswitch (mode) {\n\t\t\tcase ImplementationMethod.PROXIES_ON_INSTANCE_AND_PROTOTYPE: {\n\t\t\t\treturn (withProxiesOnThisAndPrototype as any)(...classes)\n\t\t\t}\n\t\t\tcase ImplementationMethod.PROXIES_ON_PROTOTYPE: {\n\t\t\t\treturn (withProxiesOnPrototype as any)(...classes)\n\t\t\t}\n\t\t\tcase ImplementationMethod.PROXY_AFTER_INSTANCE_AND_PROTOTYPE: {\n\t\t\t\tthrow new Error(' not implemented yet')\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Mixes the given classes into a single class. This is useful for multiple\n * inheritance.\n *\n * @example\n * class Foo {}\n * class Bar {}\n * class Baz {}\n * class MyClass extends multiple(Foo, Bar, Baz) {}\n */\nexport const multiple = makeMultipleHelper({method: ImplementationMethod.PROXIES_ON_INSTANCE_AND_PROTOTYPE})\n// export const multiple = makeMultipleHelper({method: ImplementationMethod.PROXIES_ON_PROTOTYPE})\n\nfunction withProxiesOnThisAndPrototype<T extends Constructor[]>(...classes: T): CombinedClasses<T> {\n\t// avoid performance costs in special cases\n\tif (classes.length === 0) return Object as any\n\tif (classes.length === 1) return classes[0] as any\n\n\tconst FirstClass = classes.shift()!\n\n\t// inherit the first class normally. This allows for required native\n\t// inheritance in certain special cases (like inheriting from HTMLElement\n\t// when making Custom Elements).\n\tclass MultiClass extends FirstClass {\n\t\tconstructor(...args: any[]) {\n\t\t\tsuper(...args)\n\n\t\t\tconst instances: Object[] = []\n\n\t\t\t// make instances of the other classes to get/set properties on.\n\t\t\tlet Ctor: Constructor\n\t\t\tfor (let i = 0, l = classes.length; i < l; i += 1) {\n\t\t\t\tCtor = classes[i]\n\t\t\t\tconst instance = Reflect.construct(Ctor, args)\n\t\t\t\tinstances.push(instance)\n\t\t\t}\n\n\t\t\treturn new Proxy(this, {\n\t\t\t\t// No `set()` trap is needed in this Proxy handler, at least for\n\t\t\t\t// the tests so far. Methods automatically have the correct\n\t\t\t\t// receiver when the are gotten with the `get()` trap, so if any\n\t\t\t\t// methods set a property, the set happens on the expected\n\t\t\t\t// instance, just like regular [[Set]].\n\n\t\t\t\tget(target, key: string | symbol, self: MultiClass): any {\n\t\t\t\t\tif (Reflect.ownKeys(target).includes(key)) return Reflect.get(target, key, self)\n\n\t\t\t\t\tlet instance: Object\n\n\t\t\t\t\tfor (let i = 0, l = instances.length; i < l; i += 1) {\n\t\t\t\t\t\tinstance = instances[i]\n\t\t\t\t\t\tif (Reflect.ownKeys(instance).includes(key)) return Reflect.get(instance, key, self)\n\t\t\t\t\t}\n\n\t\t\t\t\tconst proto = Object.getPrototypeOf(self)\n\t\t\t\t\tif (Reflect.has(proto, key)) return Reflect.get(proto, key, self)\n\n\t\t\t\t\treturn undefined\n\t\t\t\t},\n\n\t\t\t\townKeys(target) {\n\t\t\t\t\tlet keys = Reflect.ownKeys(target)\n\n\t\t\t\t\tlet instance: Object\n\t\t\t\t\tlet instanceKeys: (string | symbol)[]\n\n\t\t\t\t\tfor (let i = 0, l = instances.length; i < l; i += 1) {\n\t\t\t\t\t\tinstance = instances[i]\n\t\t\t\t\t\tinstanceKeys = Reflect.ownKeys(instance)\n\t\t\t\t\t\tfor (let j = 0, l = instanceKeys.length; j < l; j += 1) keys.push(instanceKeys[j])\n\t\t\t\t\t}\n\n\t\t\t\t\treturn keys\n\t\t\t\t},\n\n\t\t\t\t// This makes the `in` operator work, for example.\n\t\t\t\thas(target, key: string | symbol): boolean {\n\t\t\t\t\tif (Reflect.ownKeys(target).includes(key)) return true\n\n\t\t\t\t\tlet instance: Object\n\t\t\t\t\tfor (let i = 0, l = instances.length; i < l; i += 1) {\n\t\t\t\t\t\tinstance = instances[i]\n\t\t\t\t\t\tif (Reflect.ownKeys(instance).includes(key)) return true\n\t\t\t\t\t}\n\n\t\t\t\t\t// all instances share the same prototype, so just check it once\n\t\t\t\t\tconst proto = Object.getPrototypeOf(self)\n\t\t\t\t\tif (Reflect.has(proto, key)) return true\n\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\tconst newMultiClassPrototype = new Proxy(Object.create(FirstClass.prototype), {\n\t\tget(target, key: string | symbol, self: MultiClass): any {\n\t\t\tif (Reflect.has(target, key)) return Reflect.get(target, key, self)\n\n\t\t\tlet Class: Constructor\n\t\t\tfor (let i = 0, l = classes.length; i < l; i += 1) {\n\t\t\t\tClass = classes[i]\n\t\t\t\tif (Reflect.has(Class.prototype, key)) return Reflect.get(Class.prototype, key, self)\n\t\t\t}\n\t\t},\n\n\t\thas(target, key): boolean {\n\t\t\tif (Reflect.has(target, key)) return true\n\n\t\t\tlet Class: Constructor\n\t\t\tfor (let i = 0, l = classes.length; i < l; i += 1) {\n\t\t\t\tClass = classes[i]\n\t\t\t\tif (Reflect.has(Class.prototype, key)) return true\n\t\t\t}\n\n\t\t\treturn false\n\t\t},\n\t})\n\n\t// This is so that `super` calls will work. We can't replace\n\t// MultiClass.prototype with a Proxy because MultiClass.prototype is\n\t// non-configurable, so it is impossible to wrap it with a Proxy. Instead,\n\t// we stick our own custom Proxy-wrapped prototype object between\n\t// MultiClass.prototype and FirstClass.prototype.\n\tObject.setPrototypeOf(MultiClass.prototype, newMultiClassPrototype)\n\n\treturn MultiClass as unknown as CombinedClasses<T>\n}\n\nlet currentSelf: Object[] = []\n\nconst __instances__ = new WeakMap<object, Object[]>()\nconst getInstances = (inst: object): Object[] => {\n\tlet result = __instances__.get(inst)\n\tif (!result) __instances__.set(inst, (result = []))\n\treturn result\n}\n\n// function hasKey(instance: object, key: string | number | symbol, traverse: boolean = true): boolean {\n// \tif (Reflect.ownKeys(instance).includes(key)) return true\n\n// \tif (!traverse) return false\n\n// \tconst instances = __instances__.get(instance)\n// \tif (!instances) return false\n\n// \tfor (const instance of instances) if (hasKey(instance, key, true)) return true\n\n// \treturn false\n// }\n\ntype GetResult = {has: boolean; value: any}\n\nconst getResult: GetResult = {has: false, value: undefined}\n\nfunction getFromInstance(instance: object, key: string | symbol, result: GetResult): void {\n\tresult.has = false\n\tresult.value = undefined\n\n\tif (Reflect.ownKeys(instance).includes(key)) {\n\t\tresult.has = true\n\t\tresult.value = Reflect.get(instance, key)\n\t\treturn\n\t}\n\n\tconst instances = __instances__.get(instance)\n\tif (!instances) return\n\n\tfor (const instance of instances) {\n\t\t// if (hasKey(instance, key, true)) {\n\t\t//     getFromInstance(instance, key, result)\n\t\t//     return\n\t\t// }\n\n\t\tgetFromInstance(instance, key, result)\n\t\tif (result.has) return\n\t}\n}\n\nlet shouldGetFromPrototype = false\nlet topLevelMultiClassPrototype: object | null = null\n\nfunction withProxiesOnPrototype<T extends Constructor[]>(...classes: T): CombinedClasses<T> {\n\t// avoid performance costs in special cases\n\tif (classes.length === 0) return Object as any\n\tif (classes.length === 1) return classes[0] as any\n\n\tconst FirstClass = classes.shift()!\n\n\t// inherit the first class normally. This allows for required native\n\t// inheritance in certain special cases (like inheriting from HTMLElement\n\t// when making Custom Elements).\n\tclass MultiClass extends FirstClass {\n\t\tconstructor(...args: any[]) {\n\t\t\tsuper(...args)\n\n\t\t\t// This assumes no super constructor returns a different this from\n\t\t\t// their constructor. Otherwise the getInstances call won't work as\n\t\t\t// expected.\n\t\t\tconst instances = getInstances(this)\n\n\t\t\t// make instances of the other classes to get/set properties on.\n\t\t\tfor (const Ctor of classes) {\n\t\t\t\tconst instance = Reflect.construct(Ctor, args)\n\t\t\t\tinstances.push(instance)\n\t\t\t}\n\t\t}\n\t}\n\n\tconst newMultiClassPrototype = new Proxy(Object.create(FirstClass.prototype), {\n\t\tget(target, key: string | symbol, self: MultiClass): any {\n\t\t\tif (!topLevelMultiClassPrototype) topLevelMultiClassPrototype = target\n\n\t\t\tif (!shouldGetFromPrototype) {\n\t\t\t\tgetFromInstance(self, key, getResult)\n\n\t\t\t\tif (getResult.has) {\n\t\t\t\t\ttopLevelMultiClassPrototype = null\n\t\t\t\t\treturn getResult.value\n\t\t\t\t}\n\n\t\t\t\t// only the top level MultiClass subclass prototype will check\n\t\t\t\t// instances for a property. The superclass MultiClass\n\t\t\t\t// prototypes will do a regular prototype get.\n\t\t\t\tshouldGetFromPrototype = true\n\t\t\t}\n\n\t\t\t// TODO, I think instead of passing `self` we should be passing the\n\t\t\t// instances created from the classes? We need to write more tests,\n\t\t\t// especially ones that create new properties later and not at\n\t\t\t// construction time.\n\t\t\tif (shouldGetFromPrototype) {\n\t\t\t\tlet result: any = undefined\n\n\t\t\t\tif (Reflect.has(target, key)) result = Reflect.get(target, key, self)\n\n\t\t\t\tlet Class: Constructor\n\t\t\t\tfor (let i = 0, l = classes.length; i < l; i += 1) {\n\t\t\t\t\tClass = classes[i]\n\t\t\t\t\tif (Reflect.has(Class.prototype, key)) result = Reflect.get(Class.prototype, key, self)\n\t\t\t\t}\n\n\t\t\t\tif (topLevelMultiClassPrototype === target) {\n\t\t\t\t\ttopLevelMultiClassPrototype = null\n\t\t\t\t\tshouldGetFromPrototype = false\n\t\t\t\t}\n\n\t\t\t\treturn result\n\t\t\t}\n\n\t\t\t// currentSelf.push(self)\n\n\t\t\t// if (Reflect.ownKeys(self).includes(key)) {\n\t\t\t// \tcurrentSelf.pop()\n\t\t\t// \treturn Reflect.get(target, key, self)\n\t\t\t// }\n\n\t\t\t// currentSelf.pop()\n\n\t\t\t// for (const instance of getInstances(self)) {\n\t\t\t// \tcurrentSelf.push(instance)\n\n\t\t\t// \tif (Reflect.ownKeys(instance).includes(key)) {\n\t\t\t// \t\tcurrentSelf.pop()\n\t\t\t// \t\treturn Reflect.get(instance, key, instance)\n\t\t\t// \t}\n\n\t\t\t// \tcurrentSelf.pop()\n\t\t\t// }\n\n\t\t\t// return undefined\n\t\t},\n\n\t\tset(target, key: string | symbol, value: any, self): boolean {\n\t\t\tcurrentSelf.push(self)\n\n\t\t\t// If the key is in the current prototype chain, continue like normal...\n\t\t\tif (Reflect.has(target, key)) {\n\t\t\t\tcurrentSelf.pop()\n\t\t\t\treturn Reflect.set(target, key, value, self)\n\t\t\t}\n\n\t\t\tcurrentSelf.pop()\n\n\t\t\t// ...Otherwise if the key isn't, set it on one of the instances of the classes.\n\t\t\tfor (const instance of getInstances(self)) {\n\t\t\t\tcurrentSelf.push(instance)\n\n\t\t\t\tif (Reflect.has(instance, key)) {\n\t\t\t\t\tcurrentSelf.pop()\n\t\t\t\t\treturn Reflect.set(instance, key, value, instance)\n\t\t\t\t\t// return Reflect.set(instance, key, value, self)\n\t\t\t\t}\n\n\t\t\t\tcurrentSelf.pop()\n\t\t\t}\n\n\t\t\t// If the key is not found, set it like normal.\n\t\t\treturn Reflect.set(target, key, value, self)\n\t\t},\n\n\t\thas(target, key): boolean {\n\t\t\t// if (currentSelf.length) {\n\t\t\t// \tlet current = currentSelf[currentSelf.length - 1]\n\n\t\t\t// \twhile (current) {\n\t\t\t// \t\tif (Reflect.ownKeys(current).includes(key)) return true\n\t\t\t// \t\tcurrent = Reflect.getPrototypeOf(current) as MultiClass\n\t\t\t// \t}\n\n\t\t\t// \tfor (const instance of getInstances(current as MultiClass))\n\t\t\t// \t\tif (Reflect.has(instance, key)) return true\n\t\t\t// } else {\n\t\t\tif (Reflect.has(target, key)) return true\n\n\t\t\tlet Class: Constructor\n\t\t\tfor (let i = 0, l = classes.length; i < l; i += 1) {\n\t\t\t\tClass = classes[i]\n\t\t\t\tif (Reflect.has(Class.prototype, key)) return true\n\t\t\t}\n\t\t\t// }\n\n\t\t\treturn false\n\t\t},\n\t})\n\n\t// This is so that `super` calls will work. We can't replace\n\t// MultiClass.prototype with a Proxy because MultiClass.prototype is\n\t// non-configurable, so it is impossible to wrap it with a Proxy. Instead,\n\t// we stick our own custom Proxy-wrapped prototype object between\n\t// MultiClass.prototype and FirstClass.prototype.\n\tObject.setPrototypeOf(MultiClass.prototype, newMultiClassPrototype)\n\n\treturn MultiClass as unknown as CombinedClasses<T>\n}\n\n// type ConstructorUnionToInstanceTypeUnion<U> = (U extends Constructor\n//   ? (k: InstanceType<U>) => void\n//   : never) extends (k: infer I) => void\n//     ? I\n//     : never\n\ntype Shift<T extends any[]> = ((...args: T) => any) extends (_: any, ...args: infer R) => any ? R : never\ntype MixedArray<T extends Constructor<any>[]> = _MixedArray<T, {}>\ntype _MixedArray<T extends Constructor<any>[], U> = {\n\t0: new () => U\n\t1: _MixedArray<\n\t\tShift<T>,\n\t\t{\n\t\t\t[K in keyof InstanceType<T[0]> | keyof U]: K extends keyof U ? U[K] : InstanceType<T[0]>[K]\n\t\t}\n\t>\n}[T['length'] extends 0 ? 0 : 1]\n\ntype CombinedClasses<T> = T extends [] | [undefined]\n\t? typeof Object\n\t: T extends Constructor[]\n\t? MixedArray<T>\n\t: typeof Object\n","let taskIdCounter = 1,\n  isCallbackScheduled = false,\n  isPerformingWork = false,\n  taskQueue = [],\n  currentTask = null,\n  shouldYieldToHost = null,\n  yieldInterval = 5,\n  deadline = 0,\n  maxYieldInterval = 300,\n  scheduleCallback = null,\n  scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n    port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n    timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {\n  context: undefined,\n  registry: undefined\n};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return {\n    ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n    owner = Owner,\n    unowned = fn.length === 0,\n    current = detachedOwner === undefined ? owner : detachedOwner,\n    root = unowned ? UNOWNED : {\n      owned: null,\n      cleanups: null,\n      context: current ? current.context : null,\n      owner: current\n    },\n    updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);else value = value(s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n    s = SuspenseContext && useContext(SuspenseContext);\n  if (s) c.suspense = s;\n  if (!options || !options.render) c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n      fn ? fn() : untrack(onInvalidate);\n      fn = undefined;\n    }, undefined, false, 0),\n    s = SuspenseContext && useContext(SuspenseContext);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  if (arguments.length === 2 && typeof pFetcher === \"object\" || arguments.length === 1) {\n    source = true;\n    fetcher = pSource;\n    options = pFetcher || {};\n  } else {\n    source = pSource;\n    fetcher = pFetcher;\n    options = pOptions || {};\n  }\n  let pr = null,\n    initP = NO_INIT,\n    id = null,\n    loadedUnderTransition = false,\n    scheduled = false,\n    resolved = (\"initialValue\" in options),\n    dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = new Set(),\n    [value, setValue] = (options.storage || createSignal)(options.initialValue),\n    [error, setError] = createSignal(undefined),\n    [track, trigger] = createSignal(undefined, {\n      equals: false\n    }),\n    [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    let v;\n    if (options.ssrLoadFrom === \"initial\") initP = options.initialValue;else if (sharedConfig.load && (v = sharedConfig.load(id))) initP = v[0];\n  }\n  function loadEnd(p, v, error, key) {\n    if (pr === p) {\n      pr = null;\n      key !== undefined && (resolved = true);\n      if ((p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = NO_INIT;\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          completeLoad(v, error);\n        }, false);\n      } else completeLoad(v, error);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (err === undefined) setValue(() => v);\n      setState(err !== undefined ? \"errored\" : resolved ? \"ready\" : \"unresolved\");\n      setError(err);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c = SuspenseContext && useContext(SuspenseContext),\n      v = value(),\n      err = error();\n    if (err !== undefined && !pr) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled) return;\n    scheduled = false;\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP !== NO_INIT ? initP : untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(p && \"then\" in p)) {\n      loadEnd(pr, p, undefined, lookup);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, undefined, castError(e), lookup));\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s = state();\n        return s === \"pending\" || s === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        const err = error();\n        if (err && !pr) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n    timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, options);\n  updateComputation(node);\n  setDeferred(() => Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const [key, val] of subs.entries()) if (fn(key, v) !== fn(key, p)) {\n      for (const c of val.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    const listener = Listener;\n    if (listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction catchError(fn, handler) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  Owner = createComputation(undefined, undefined, true);\n  Owner.context = {\n    ...Owner.context,\n    [ERROR]: [handler]\n  };\n  if (Transition && Transition.running) Transition.sources.add(Owner);\n  try {\n    return fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = Owner.owner;\n  }\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  const prevListener = Listener;\n  Owner = o;\n  Listener = null;\n  try {\n    return runUpdates(fn, true);\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = prev;\n    Listener = prevListener;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  return Owner && Owner.context && Owner.context[context.id] !== undefined ? Owner.context[context.id] : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  const memo = createMemo(() => resolveChildren(children()));\n  memo.toArray = () => {\n    const c = memo();\n    return Array.isArray(c) ? c : c != null ? [c] : [];\n  };\n  return memo;\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext());\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (runningTransition ? this.tState : this.state)) {\n    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    if (Transition) {\n      const TransitionRunning = Transition.running;\n      if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n        Transition.sources.add(node);\n        node.tValue = value;\n      }\n      if (!TransitionRunning) node.value = value;\n    } else node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i = 0; i < node.observers.length; i += 1) {\n          const o = node.observers[i];\n          const TransitionRunning = Transition && Transition.running;\n          if (TransitionRunning && Transition.disposed.has(o)) continue;\n          if (TransitionRunning ? !o.tState : !o.state) {\n            if (o.pure) Updates.push(o);else Effects.push(o);\n            if (o.observers) markDownstream(o);\n          }\n          if (!TransitionRunning) o.state = STALE;else o.tState = STALE;\n        }\n        if (Updates.length > 10e5) {\n          Updates = [];\n          if (false) ;\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n    listener = Listener,\n    time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        Listener = Owner = node;\n        runComputation(node, node.tValue, time);\n        Listener = Owner = null;\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      if (Transition && Transition.running) {\n        node.tState = STALE;\n        node.tOwned && node.tOwned.forEach(cleanNode);\n        node.tOwned = undefined;\n      } else {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    node.updatedAt = time + 1;\n    return handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: Owner ? Owner.context : null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if ((runningTransition ? node.tState : node.state) === 0) return;\n  if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (runningTransition ? node.tState : node.state) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n        prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if ((runningTransition ? node.tState : node.state) === STALE) {\n      updateComputation(node);\n    } else if ((runningTransition ? node.tState : node.state) === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition) {\n    if (!Transition.promises.size && !Transition.queue.size) {\n      const sources = Transition.sources;\n      const disposed = Transition.disposed;\n      Effects.push.apply(Effects, Transition.effects);\n      res = Transition.resolve;\n      for (const e of Effects) {\n        \"tState\" in e && (e.state = e.tState);\n        delete e.tState;\n      }\n      Transition = null;\n      runUpdates(() => {\n        for (const d of disposed) cleanNode(d);\n        for (const v of sources) {\n          v.value = v.tValue;\n          if (v.owned) {\n            for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n          }\n          if (v.tOwned) v.owned = v.tOwned;\n          delete v.tValue;\n          delete v.tOwned;\n          v.tState = 0;\n        }\n        setTransPending(false);\n      }, false);\n    } else if (Transition.running) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n  }\n  const e = Effects;\n  Effects = null;\n  if (e.length) runUpdates(() => runEffects(e), false);\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n    userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) {\n    if (sharedConfig.count) {\n      sharedConfig.effects || (sharedConfig.effects = []);\n      sharedConfig.effects.push(...queue.slice(0, userLength));\n      return;\n    } else if (sharedConfig.effects) {\n      queue = [...sharedConfig.effects, ...queue];\n      userLength += sharedConfig.effects.length;\n      delete sharedConfig.effects;\n    }\n    setHydrateContext();\n  }\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      const state = runningTransition ? source.tState : source.state;\n      if (state === STALE) {\n        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);\n      } else if (state === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (runningTransition ? !o.tState : !o.state) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n        index = node.sourceSlots.pop(),\n        obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n          s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction castError(err) {\n  if (err instanceof Error) return err;\n  return new Error(typeof err === \"string\" ? err : \"Unknown error\", {\n    cause: err\n  });\n}\nfunction runErrors(err, fns, owner) {\n  try {\n    for (const f of fns) f(err);\n  } catch (e) {\n    handleError(e, owner && owner.owner || null);\n  }\n}\nfunction handleError(err, owner = Owner) {\n  const fns = ERROR && owner && owner.context && owner.context[ERROR];\n  const error = castError(err);\n  if (!fns) throw error;\n  if (Effects) Effects.push({\n    fn() {\n      runErrors(error, fns, owner);\n    },\n    state: STALE\n  });else runErrors(error, fns, owner);\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(() => res = untrack(() => {\n      Owner.context = {\n        ...Owner.context,\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }), undefined);\n    return res;\n  };\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null || !Owner.context[ERROR]) {\n    Owner.context = {\n      ...Owner.context,\n      [ERROR]: [fn]\n    };\n    mutateContext(Owner, ERROR, [fn]);\n  } else Owner.context[ERROR].push(fn);\n}\nfunction mutateContext(o, key, value) {\n  if (o.owned) {\n    for (let i = 0; i < o.owned.length; i++) {\n      if (o.owned[i].context === o.context) mutateContext(o.owned[i], key, value);\n      if (!o.owned[i].context) {\n        o.owned[i].context = o.context;\n        mutateContext(o.owned[i], key, value);\n      } else if (!o.owned[i].context[key]) {\n        o.owned[i].context[key] = value;\n        mutateContext(o.owned[i], key, value);\n      }\n    }\n  }\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = typeof observer === \"function\" ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createEffect(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    len = 0,\n    indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n      i,\n      j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n        newIndices,\n        newIndicesNext,\n        temp,\n        tempdisposers,\n        tempIndexes,\n        start,\n        end,\n        newEnd,\n        item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n    mapped = [],\n    disposers = [],\n    signals = [],\n    len = 0,\n    i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return !(s = typeof s === \"function\" ? s() : s) ? {} : s;\n}\nfunction resolveSources() {\n  for (let i = 0, length = this.length; i < length; ++i) {\n    const v = this[i]();\n    if (v !== undefined) return v;\n  }\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i = 0; i < sources.length; i++) {\n    const s = sources[i];\n    proxy = proxy || !!s && $PROXY in s;\n    sources[i] = typeof s === \"function\" ? (proxy = true, createMemo(s)) : s;\n  }\n  if (proxy) {\n    return new Proxy({\n      get(property) {\n        for (let i = sources.length - 1; i >= 0; i--) {\n          const v = resolveSource(sources[i])[property];\n          if (v !== undefined) return v;\n        }\n      },\n      has(property) {\n        for (let i = sources.length - 1; i >= 0; i--) {\n          if (property in resolveSource(sources[i])) return true;\n        }\n        return false;\n      },\n      keys() {\n        const keys = [];\n        for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n        return [...new Set(keys)];\n      }\n    }, propTraps);\n  }\n  const target = {};\n  const sourcesMap = {};\n  const defined = new Set();\n  for (let i = sources.length - 1; i >= 0; i--) {\n    const source = sources[i];\n    if (!source) continue;\n    const sourceKeys = Object.getOwnPropertyNames(source);\n    for (let i = 0, length = sourceKeys.length; i < length; i++) {\n      const key = sourceKeys[i];\n      if (key === \"__proto__\" || key === \"constructor\") continue;\n      const desc = Object.getOwnPropertyDescriptor(source, key);\n      if (!defined.has(key)) {\n        if (desc.get) {\n          defined.add(key);\n          Object.defineProperty(target, key, {\n            enumerable: true,\n            configurable: true,\n            get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])\n          });\n        } else {\n          if (desc.value !== undefined) defined.add(key);\n          target[key] = desc.value;\n        }\n      } else {\n        const sources = sourcesMap[key];\n        if (sources) {\n          if (desc.get) {\n            sources.push(desc.get.bind(source));\n          } else if (desc.value !== undefined) {\n            sources.push(() => desc.value);\n          }\n        } else if (target[key] === undefined) target[key] = desc.value;\n      }\n    }\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  if ($PROXY in props) {\n    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);\n    const res = keys.map(k => {\n      return new Proxy({\n        get(property) {\n          return k.includes(property) ? props[property] : undefined;\n        },\n        has(property) {\n          return k.includes(property) && property in props;\n        },\n        keys() {\n          return k.filter(property => property in props);\n        }\n      }, propTraps);\n    });\n    res.push(new Proxy({\n      get(property) {\n        return blocked.has(property) ? undefined : props[property];\n      },\n      has(property) {\n        return blocked.has(property) ? false : property in props;\n      },\n      keys() {\n        return Object.keys(props).filter(k => !blocked.has(k));\n      }\n    }, propTraps));\n    return res;\n  }\n  const otherObject = {};\n  const objects = keys.map(() => ({}));\n  for (const propName of Object.getOwnPropertyNames(props)) {\n    const desc = Object.getOwnPropertyDescriptor(props, propName);\n    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;\n    let blocked = false;\n    let objectIndex = 0;\n    for (const k of keys) {\n      if (k.includes(propName)) {\n        blocked = true;\n        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);\n      }\n      ++objectIndex;\n    }\n    if (!blocked) {\n      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);\n    }\n  }\n  return [...objects, otherObject];\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      sharedConfig.count || (sharedConfig.count = 0);\n      sharedConfig.count++;\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        sharedConfig.count--;\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (false) ;\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nconst narrowedError = name => `Stale read from <${name}>.`;\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback || undefined));\n}\nfunction Show(props) {\n  const keyed = props.keyed;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => keyed ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      const fn = typeof child === \"function\" && child.length > 0;\n      return fn ? untrack(() => child(keyed ? c : () => {\n        if (!untrack(condition)) throw narrowedError(\"Show\");\n        return props.when;\n      })) : child;\n    }\n    return props.fallback;\n  }, undefined, undefined);\n}\nfunction Switch(props) {\n  let keyed = false;\n  const equals = (a, b) => a[0] === b[0] && (keyed ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2];\n  const conditions = children(() => props.children),\n    evalConditions = createMemo(() => {\n      let conds = conditions();\n      if (!Array.isArray(conds)) conds = [conds];\n      for (let i = 0; i < conds.length; i++) {\n        const c = conds[i].when;\n        if (c) {\n          keyed = !!conds[i].keyed;\n          return [i, c, conds[i]];\n        }\n      }\n      return [-1];\n    }, undefined, {\n      equals\n    });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    const fn = typeof c === \"function\" && c.length > 0;\n    return fn ? untrack(() => c(keyed ? when : () => {\n      if (untrack(evalConditions)[0] !== index) throw narrowedError(\"Match\");\n      return cond.when;\n    })) : c;\n  }, undefined, undefined);\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn());\n}\nfunction ErrorBoundary(props) {\n  let err;\n  let v;\n  if (sharedConfig.context && sharedConfig.load && (v = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count))) err = v[0];\n  const [errored, setErrored] = createSignal(err, undefined);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(() => {\n    let e;\n    if (e = errored()) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored())) : f;\n    }\n    return catchError(() => props.children, setErrored);\n  }, undefined, undefined);\n}\n\nconst suspenseListEquals = (a, b) => a.showContent === b.showContent && a.showFallback === b.showFallback;\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let [wrapper, setWrapper] = createSignal(() => ({\n      inFallback: false\n    })),\n    show;\n  const listContext = useContext(SuspenseListContext);\n  const [registry, setRegistry] = createSignal([]);\n  if (listContext) {\n    show = listContext.register(createMemo(() => wrapper()().inFallback));\n  }\n  const resolved = createMemo(prev => {\n    const reveal = props.revealOrder,\n      tail = props.tail,\n      {\n        showContent = true,\n        showFallback = true\n      } = show ? show() : {},\n      reg = registry(),\n      reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = reg.every(inFallback => !inFallback());\n      const res = reg.map(() => ({\n        showContent: all && showContent,\n        showFallback\n      }));\n      res.inFallback = !all;\n      return res;\n    }\n    let stop = false;\n    let inFallback = prev.inFallback;\n    const res = [];\n    for (let i = 0, len = reg.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n        s = reg[n]();\n      if (!stop && !s) {\n        res[n] = {\n          showContent,\n          showFallback\n        };\n      } else {\n        const next = !stop;\n        if (next) inFallback = true;\n        res[n] = {\n          showContent: next,\n          showFallback: !tail || next && tail === \"collapsed\" ? showFallback : false\n        };\n        stop = true;\n      }\n    }\n    if (!stop) inFallback = false;\n    res.inFallback = inFallback;\n    return res;\n  }, {\n    inFallback: false\n  });\n  setWrapper(() => resolved);\n  return createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        let index;\n        setRegistry(registry => {\n          index = registry.length;\n          return [...registry, inFallback];\n        });\n        return createMemo(() => resolved()[index], undefined, {\n          equals: suspenseListEquals\n        });\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction Suspense(props) {\n  let counter = 0,\n    show,\n    ctx,\n    p,\n    flicker,\n    error;\n  const [inFallback, setFallback] = createSignal(false),\n    SuspenseContext = getSuspenseContext(),\n    store = {\n      increment: () => {\n        if (++counter === 1) setFallback(true);\n      },\n      decrement: () => {\n        if (--counter === 0) setFallback(false);\n      },\n      inFallback,\n      effects: [],\n      resolved: false\n    },\n    owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    let ref = sharedConfig.load(key);\n    if (ref && (p = ref[0]) && p !== \"$$f\") {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if (err || sharedConfig.done) {\n          err && (error = err);\n          return set();\n        }\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) show = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === \"$$f\") setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(prev => {\n          const inFallback = store.inFallback(),\n            {\n              showContent = true,\n              showFallback = true\n            } = show ? show() : {};\n          if ((!inFallback || p && p !== \"$$f\") && showContent) {\n            store.resolved = true;\n            dispose && dispose();\n            dispose = ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!showFallback) return;\n          if (dispose) return prev;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nconst DEV = undefined;\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, catchError, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","import {Constructor} from 'lowclass'\nimport {onMount, createEffect, onCleanup, type JSX, $TRACK, createMemo} from 'solid-js'\nimport type {DecoratorContext} from './decorators/types'\n\n// https://github.com/ryansolid/dom-expressions/pull/122\n\ninterface PossibleComponent {\n\tonMount?(): void\n\tonCleanup?(): void\n\ttemplate?(props: Record<string, unknown>): JSX.Element\n}\ninterface PossiblyReactiveConstructor {}\n\n/**\n * A decorator for using classes as Solid components.\n *\n * Example:\n *\n * > Note in the following example that `\\@` should be written as `@` without\n * the back slash. The back slash prevents JSDoc parsing errors in this comment\n * in TypeScript.  https://github.com/microsoft/TypeScript/issues/47679\n *\n * ```js\n * \\@component\n * \\@reactive\n * class MyComp {\n *   \\@signal last = 'none'\n *\n *   onMount() {\n *     console.log('mounted')\n *   }\n *\n *   template(props) {\n *     // here we use `props` passed in, or the signal on `this` which is also\n *     // treated as a prop\n *     return <h1>Hello, my name is {props.first} {this.last}</h1>\n *   }\n * }\n *\n * render(() => <MyComp first=\"Joe\" last=\"Pea\" />)\n * ```\n */\nexport function component<T extends Constructor>(Base: T, ...args: any): any {\n\tconst [context] = args as [DecoratorContext]\n\n\tif (typeof Base !== 'function' || (context && context.kind !== 'class'))\n\t\tthrow new Error('The @component decorator should only be used on a class.')\n\n\tconst Class = Constructor<PossibleComponent, PossiblyReactiveConstructor>(Base)\n\n\treturn function (props: Record<string | symbol, unknown>): JSX.Element {\n\t\tconst instance = new Class()\n\n\t\tconst keys = createMemo(\n\t\t\t() => {\n\t\t\t\tprops[$TRACK]\n\t\t\t\treturn Object.keys(props)\n\t\t\t},\n\t\t\t[],\n\t\t\t{\n\t\t\t\tequals(prev, next) {\n\t\t\t\t\tif (prev.length !== next.length) return false\n\t\t\t\t\tfor (let i = 0, l = prev.length; i < l; i += 1) if (prev[i] !== next[i]) return false\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\n\t\tcreateEffect(() => {\n\t\t\tfor (const prop of keys()) {\n\t\t\t\tcreateEffect(() => {\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tinstance[prop] = props[prop]\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\n\t\tif (instance.onMount) onMount(() => instance.onMount?.())\n\t\tif (instance.onCleanup) onCleanup(() => instance.onCleanup?.())\n\n\t\treturn instance.template?.(props) ?? null\n\t}\n}\n\ndeclare module 'solid-js' {\n\tnamespace JSX {\n\t\t// Tells JSX what properties class components should have.\n\t\tinterface ElementClass {\n\t\t\ttemplate?(props: Record<string, unknown>): JSX.Element\n\t\t}\n\n\t\t// Tells JSX where to look up prop types on class components.\n\t\tinterface ElementAttributesProperty {\n\t\t\tPropTypes: {}\n\t\t}\n\t}\n}\n\nexport type Props<T extends object, K extends keyof T> = Pick<T, K> & {\n\tchildren?: JSX.Element\n}\n","// TODO switch to non-dep-tracking non-queue-modifying deferred signals, because those do not break with regular effects.\n\nimport {createSignal as _createSignal, createEffect, onCleanup, getOwner, runWithOwner} from 'solid-js'\n\nimport type {EffectFunction} from 'solid-js/types/reactive/signal'\n\nconst effectQueue: Set<EffectFunction<any>> = new Set()\nlet runningEffects = false\n\n// map of effects to dependencies\nconst effectDeps = new Map<EffectFunction<any>, Set<(v: any) => any>>()\nlet currentEffect: EffectFunction<any> = () => {}\n\n// Override createSignal in order to implement custom tracking of effect\n// dependencies, so that when signals change, we are aware which dependenct\n// effects need to be moved to the end of the effect queue while running\n// deferred effects in a microtask.\nexport let createSignal = ((value, options) => {\n\tlet [_get, _set] = _createSignal(value, options)\n\n\tconst get = (() => {\n\t\tif (!runningEffects) return _get()\n\n\t\tlet deps = effectDeps.get(currentEffect)\n\t\tif (!deps) effectDeps.set(currentEffect, (deps = new Set()))\n\t\tdeps.add(_set)\n\n\t\treturn _get()\n\t}) as typeof _get\n\n\tconst set = (v => {\n\t\tif (!runningEffects) return _set(v as any)\n\n\t\t// This is inefficient, for proof of concept, unable to use Solid\n\t\t// internals on the outside.\n\t\tfor (const [fn, deps] of effectDeps) {\n\t\t\tfor (const dep of deps) {\n\t\t\t\tif (dep === _set) {\n\t\t\t\t\t// move to the end\n\t\t\t\t\teffectQueue.delete(fn)\n\t\t\t\t\teffectQueue.add(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn _set(v as any)\n\t}) as typeof _set\n\n\treturn [get, set]\n}) as typeof _createSignal\n\nlet effectTaskIsScheduled = false\n\n// TODO Option so the first run is deferred instead of immediate? This already\n// happens outside of a root.\nexport const createDeferredEffect = ((fn, value, options) => {\n\tlet initial = true\n\n\tcreateEffect(\n\t\t(prev: any) => {\n\t\t\tif (initial) {\n\t\t\t\tinitial = false\n\n\t\t\t\tcurrentEffect = fn\n\t\t\t\teffectDeps.get(fn)?.clear() // clear to track deps, or else it won't track new deps based on code branching\n\t\t\t\tfn(prev)\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\teffectQueue.add(fn) // add, or move to the end, of the queue. TODO This is probably redundant now, but I haven't tested yet.\n\n\t\t\t// If we're currently running the queue, return because fn will run\n\t\t\t// again at the end of the queue iteration due to our overriden\n\t\t\t// createSignal moving it to the end.\n\t\t\tif (runningEffects) return\n\n\t\t\tif (effectTaskIsScheduled) return\n\n\t\t\teffectTaskIsScheduled = true\n\n\t\t\tconst owner = getOwner()\n\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (owner) runWithOwner(owner, runEffects)\n\t\t\t\telse runEffects()\n\t\t\t})\n\t\t},\n\t\tvalue,\n\t\toptions,\n\t)\n\n\tgetOwner() &&\n\t\tonCleanup(() => {\n\t\t\teffectDeps.delete(fn)\n\t\t\teffectQueue.delete(fn)\n\t\t})\n}) as typeof createEffect\n\nfunction runEffects() {\n\trunningEffects = true\n\n\tfor (const fn of effectQueue) {\n\t\teffectQueue.delete(fn) // TODO This is probably redundant now, but I haven't tested yet.\n\t\tcreateDeferredEffect(fn)\n\t}\n\n\trunningEffects = false\n\teffectTaskIsScheduled = false\n}\n","// FIXME Solid 1.7.9+ requires a TypeScript update, so classy-solid code is made\n// un-typesafe until we update.\n\n// import {createSignal} from './createDeferredEffect.js'\nimport {createSignal} from 'solid-js'\n// import type {Setter} from 'solid-js'\nimport type {SignalOptions} from 'solid-js/types/reactive/signal'\n\n/**\n * A single function that with no args passed reads a signal, otherwise sets a\n * signal just like a Setter does.\n */\n// export type SignalFunction<T> = {(): T} & Setter<T> // FIXME broke in 1.7.9\nexport type SignalFunction<T> = {(v?: T | ((prev: T) => T)): T}\n\n/**\n * Create a Solid signal wrapped as a single function that gets the value when\n * no arguments are passed in, and sets the value when an argument is passed in.\n * Good for alternative usage patterns, such as when read/write segregation is\n * not needed.\n *\n * ```js\n * let count = createSignalFunction(0) // create it with default value\n * count(1) // set the value\n * count(count() + 1) // increment\n * let currentValue = count() // read the current value\n * ```\n *\n * This is more convenient for class properties than using `createSignal`. With `createSignal`:\n *\n * ```js\n * class Foo {\n *   count = createSignal(0)\n *\n *   increment() {\n *     // difficult to read\n *     this.count[1](this.count[0]() + 1)\n *\n *     // also:\n *     this.count[1](c => c + 1)\n *   }\n * }\n * ```\n *\n * With `createSignalFunction`:\n *\n * ```js\n * class Foo {\n *   count = createSignalFunction(0)\n *\n *   increment() {\n *     // Easier to read\n *     this.count(this.count() + 1)\n *\n *     // also:\n *     this.count(c => c + 1)\n *   }\n * }\n * ```\n *\n * See also `createSignalObject` for another pattern.\n */\nexport function createSignalFunction<T>(): SignalFunction<T | undefined>\nexport function createSignalFunction<T>(value: T, options?: SignalOptions<T>): SignalFunction<T>\nexport function createSignalFunction<T>(value?: T, options?: SignalOptions<T>): SignalFunction<T> {\n\tconst [get, set] = createSignal<T>(value as T, options)\n\n\treturn function (value) {\n\t\tif (arguments.length === 0) return get()\n\t\treturn set(\n\t\t\t// @ts-ignore FIXME its ok, value is defined (even if `undefined`)\n\t\t\tvalue,\n\t\t)\n\t} as SignalFunction<T>\n}\n","import {createSignal} from './createDeferredEffect.js'\nimport type {SignalOptions} from 'solid-js/types/reactive/signal'\nimport type {Signal} from 'solid-js/types/reactive/signal'\n\n/**\n * A signal represented as an object with .get and .set methods.\n */\nexport interface SignalObject<T> {\n\t/** Gets the signal value. */\n\tget: Signal<T>[0]\n\t/** Sets the signal value. */\n\t// set: Signal<T>[1] // FIXME broke in Solid 1.7.9\n\tset: (v: T | ((prev: T) => T)) => T\n}\n\n/**\n * Create a Solid signal wrapped in the form of an object with `.get` and `.set`\n * methods for alternative usage patterns.\n *\n * ```js\n * let count = createSignalObject(0) // count starts at 0\n * count.set(1) // set the value of count to 1\n * count.set(count.get() + 1) // add 1\n * let currentValue = count.get() // read the current value\n * ```\n *\n * This is more convenient for class properties than using `createSignal`. With `createSignal`:\n *\n * ```js\n * class Foo {\n *   count = createSignal(0)\n *\n *   increment() {\n *     // difficult to read\n *     this.count[1](this.count[0]() + 1)\n *\n *     // also:\n *     this.count[1](c => c + 1)\n *   }\n * }\n * ```\n *\n * With `createSignalObject`:\n *\n * ```js\n * class Foo {\n *   count = createSignalObject(0)\n *\n *   increment() {\n *     // Easier to read\n *     this.count.set(this.count.get() + 1)\n *\n *     // also:\n *     this.count.set(c => c + 1)\n *   }\n * }\n * ```\n *\n * See also `createSignalFunction` for another pattern.\n */\nexport function createSignalObject<T>(): SignalObject<T | undefined>\nexport function createSignalObject<T>(value: T, options?: SignalOptions<T>): SignalObject<T>\nexport function createSignalObject<T>(value?: T, options?: SignalOptions<T>): SignalObject<T> {\n\tconst [get, set] = createSignal<T>(value as T, options)\n\treturn {get, set}\n}\n","import {getInheritedDescriptor} from 'lowclass'\nimport {createSignal, $PROXY} from 'solid-js'\nimport type {Signal} from 'solid-js/types/reactive/signal'\nimport type {PropKey, PropSpec} from './decorators/types.js'\n\nconst signalifiedProps = new WeakMap<object, Set<string | symbol>>()\n\n/**\n * Convert properties on an object into Solid signal-backed properties.\n *\n * There are two ways to use this: either by defining which properties to\n * convert to signal-backed properties by providing an array as property names\n * in the second arg, which is useful on plain objects, or by passing in `this`\n * and `this.constructor` within the `constructor` of a class that has\n * properties decorated with `@signal`.\n *\n * Example with a class:\n *\n * ```js\n * import {signalify} from 'classy-solid'\n * import {createEffect} from 'solid-js'\n *\n * class Counter {\n *   count = 0\n *\n *   constructor() {\n *     signalify(this, 'count')\n *     setInterval(() => this.count++, 1000)\n *   }\n * }\n *\n * const counter = new Counter\n *\n * createEffect(() => {\n *   console.log('count:', counter.count)\n * })\n * ```\n *\n * Example with a plain object:\n *\n * ```js\n * import {signalify} from 'classy-solid'\n * import {createEffect} from 'solid-js'\n *\n * const counter = {\n *   count: 0\n * }\n *\n * signalify(counter, 'count')\n * setInterval(() => counter.count++, 1000)\n *\n * createEffect(() => {\n *   console.log('count:', counter.count)\n * })\n * ```\n */\nexport function signalify<T extends object>(obj: T, ...props: (keyof T)[]): T\nexport function signalify<T extends object, K extends keyof T>(obj: T): T\nexport function signalify(obj: Obj, ...props: [] | [Map<PropKey, PropSpec>] | PropertyKey[]) {\n\t// We cast from PropertyKey[] to PropKey[] because numbers can't actually be keys, only string | symbol.\n\tconst _props = props.length\n\t\t? (props as PropKey[])\n\t\t: (Object.keys(obj) as PropKey[]).concat(Object.getOwnPropertySymbols(obj))\n\n\tfor (const prop of _props) createSignalAccessor(obj, prop)\n\n\treturn obj\n}\n\nlet gotCreateSignalAccessor = false\n\n/**\n * This ensures that `createSignalAccessor` is kept internal to classy-solid only.\n */\nexport function getCreateSignalAccessor() {\n\tif (gotCreateSignalAccessor) throw new Error('Export \"createSignalAccessor\" is internal to classy-solid only.')\n\tgotCreateSignalAccessor = true\n\treturn createSignalAccessor\n}\n\nfunction createSignalAccessor<T extends object>(\n\tobj: T,\n\tprop: Exclude<keyof T, number>,\n\tinitialVal: unknown = obj[prop],\n): void {\n\tif (signalifiedProps.get(obj)?.has(prop)) return\n\n\t// Special case for Solid proxies: if the object is already a solid proxy,\n\t// all properties are already reactive, no need to signalify.\n\t// @ts-expect-error special indexed access\n\tconst proxy = obj[$PROXY] as T\n\tif (proxy) return\n\n\t// XXX If obj already has a signal, skip making an accessor? I think perhaps\n\t// not, because a subclass might override a property so it is not reactive,\n\t// and a further subclass might want to make it reactive again in which\n\t// case returning early would cause the subclass subclass's property not to\n\t// be reactive.\n\t// if (signals.get(obj)?.get(propName) !== undefined) return\n\n\tlet descriptor: PropertyDescriptor | undefined = getInheritedDescriptor(obj, prop)\n\n\tlet originalGet: (() => any) | undefined\n\tlet originalSet: ((v: any) => void) | undefined\n\n\t// TODO if there is an inherited accessor, we need to ensure we still call\n\t// it so that we're extending instead of overriding. Otherwise placing\n\t// @reactive on a property will break that functionality in those cases.\n\t//\n\t// Right now, originalGet will only be called if it is on the current\n\t// prototype, but we aren't checking for any accessor that may be inherited.\n\n\tif (descriptor) {\n\t\toriginalGet = descriptor.get\n\t\toriginalSet = descriptor.set\n\n\t\tif (originalGet || originalSet) {\n\t\t\t// reactivity requires both\n\t\t\tif (!originalGet || !originalSet) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`The \\`@signal\\` decorator was used on an accessor named \"${prop.toString()}\" which had a getter or a setter, but not both. Reactivity on accessors works only when accessors have both get and set. In this case the decorator does not do anything.`,\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdelete descriptor.get\n\t\t\tdelete descriptor.set\n\t\t} else {\n\t\t\t// If there was a value descriptor, trust it as the source of truth\n\t\t\t// for initialVal. For example, if the user class modifies the value\n\t\t\t// after the initializer, it will have a different value than what\n\t\t\t// we tracked from the initializer.\n\t\t\tinitialVal = descriptor.value\n\n\t\t\t// if it isn't writable, we don't need to make a reactive variable because\n\t\t\t// the value won't change\n\t\t\tif (!descriptor.writable) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`The \\`@signal\\` decorator was used on a property named \"${prop.toString()}\" that is not writable. Reactivity is not enabled for non-writable properties.`,\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdelete descriptor.value\n\t\t\tdelete descriptor.writable\n\t\t}\n\t}\n\n\tdescriptor = {\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\t...descriptor,\n\t\tget: originalGet\n\t\t\t? function (this: T): unknown {\n\t\t\t\t\tconst s = getSignal(this, prop, initialVal)\n\t\t\t\t\ts[0]() // read\n\t\t\t\t\treturn originalGet!.call(this)\n\t\t\t  }\n\t\t\t: function (this: any): unknown {\n\t\t\t\t\tconst s = getSignal(this, prop, initialVal)\n\t\t\t\t\treturn s[0]() // read\n\t\t\t  },\n\t\tset: originalSet\n\t\t\t? function (this: any, newValue: unknown) {\n\t\t\t\t\toriginalSet!.call(this, newValue)\n\n\t\t\t\t\t// __propsSetAtLeastOnce__ is a Set that tracks which reactive\n\t\t\t\t\t// properties have been set at least once. @lume/element uses this\n\t\t\t\t\t// to detect if a reactive prop has been set, and if so will not\n\t\t\t\t\t// overwrite the value with any value from custom element\n\t\t\t\t\t// pre-upgrade.\n\t\t\t\t\tif (!this.__propsSetAtLeastOnce__) this.__propsSetAtLeastOnce__ = new Set<string>()\n\t\t\t\t\tthis.__propsSetAtLeastOnce__.add(prop)\n\n\t\t\t\t\tconst v = getSignal(this, prop)\n\t\t\t\t\t// write\n\t\t\t\t\tif (typeof newValue === 'function') v[1](() => newValue)\n\t\t\t\t\telse v[1](newValue)\n\t\t\t  }\n\t\t\t: function (this: any, newValue: unknown) {\n\t\t\t\t\tif (!this.__propsSetAtLeastOnce__) this.__propsSetAtLeastOnce__ = new Set<string>()\n\t\t\t\t\tthis.__propsSetAtLeastOnce__.add(prop)\n\n\t\t\t\t\tconst v = getSignal(this, prop)\n\t\t\t\t\t// write\n\t\t\t\t\tif (typeof newValue === 'function') v[1](() => newValue)\n\t\t\t\t\telse v[1](newValue)\n\t\t\t  },\n\t}\n\n\tObject.defineProperty(obj, prop, descriptor)\n\n\tif (!signalifiedProps.has(obj)) signalifiedProps.set(obj, new Set())\n\tsignalifiedProps.get(obj)!.add(prop)\n}\n\nconst signals = new WeakMap<object, Map<PropKey, Signal<unknown>>>()\n\nfunction getSignal<T>(instance: object, signalKey: PropKey, initialValue: T = undefined!): Signal<T> {\n\tif (!signals.has(instance)) signals.set(instance, new Map())\n\n\tlet s = signals.get(instance)!.get(signalKey) as Signal<T> | undefined\n\n\tif (s) return s\n\n\ts = createSignal<T>(initialValue, {equals: false})\n\tsignals.get(instance)?.set(signalKey, s as Signal<unknown>)\n\n\treturn s\n}\n\ntype Obj = Record<PropKey, unknown>\n","import type {DecoratorArgs, PropKey, PropSpec} from './types.js'\n\nlet propsToSignalify = new Map<PropKey, PropSpec>()\nlet accessKey: symbol | null = null\n\n/**\n * Provides a key for accessing internal APIs. If any other module tries to get\n * this, an error will be thrown, and signal and reactive decorators will not\n * work.\n */\nexport function getKey() {\n\tif (accessKey) throw new Error('Attempted use of classy-solid internals.')\n\taccessKey = Symbol()\n\treturn accessKey\n}\n\n/**\n * This function provides propsToSignalify to only one external module\n * (reactive.ts). The purpose of this is to keep the API private for reactive.ts\n * only, otherwise an error will be thrown that breaks signal/reactive\n * functionality.\n */\nexport function getPropsToSignalify(key: symbol) {\n\tif (key !== accessKey) throw new Error('Attempted use of classy-solid internals.')\n\treturn propsToSignalify\n}\n\n/**\n * Only the module that first gets the key can call this function (it should be\n * reactive.ts)\n */\nexport function resetPropsToSignalify(key: symbol) {\n\tif (key !== accessKey) throw new Error('Attempted use of classy-solid internals.')\n\tpropsToSignalify = new Map<PropKey, PropSpec>()\n}\n\n/**\n * @decorator\n * Decorate properties of a class with `@signal` to back them with Solid\n * signals, making them reactive. Don't forget that the class in which `@signal`\n * is used must be decorated with `@reactive`.\n *\n * Example:\n *\n * > Note in the following example that `\\@` should be written as `@` without\n * the back slash. The back slash prevents JSDoc parsing errors in this comment\n * in TypeScript.  https://github.com/microsoft/TypeScript/issues/47679\n *\n * ```js\n * import {reactive, signal} from 'classy-solid'\n * import {createEffect} from 'solid-js'\n *\n * \\@reactive\n * class Counter {\n *   \\@signal count = 0\n *\n *   constructor() {\n *     setInterval(() => this.count++, 1000)\n *   }\n * }\n *\n * const counter = new Counter\n *\n * createEffect(() => {\n *   console.log('count:', counter.count)\n * })\n * ```\n */\nexport function signal(...args: any[]): any {\n\tconst [_, {kind, name, private: isPrivate, static: isStatic}] = args as DecoratorArgs\n\tconst props = propsToSignalify\n\n\tif (isPrivate) throw new Error('@signal is not supported on private fields yet.')\n\tif (isStatic) throw new Error('@signal is not supported on static fields yet.')\n\n\tif (kind === 'field') {\n\t\tprops.set(name, {initialValue: undefined})\n\t\treturn function (this: object, initialValue: unknown) {\n\t\t\tprops.get(name)!.initialValue = initialValue\n\t\t\treturn initialValue\n\t\t}\n\t} else if (kind === 'accessor') {\n\t\tthrow new Error('@signal not supported on `accessor` fields yet.')\n\t} else if (kind === 'getter' || kind === 'setter') {\n\t\tprops.set(name, {initialValue: undefined})\n\t} else {\n\t\tthrow new Error('The @signal decorator is only for use on fields, accessors, getters, and setters.')\n\t}\n\n\t// @prod-prune\n\tqueueReactiveDecoratorChecker(props)\n}\n\nlet checkerQueued = false\n\n/**\n * This throws an error in some cases of an end dev forgetting to decorate a\n * class with @reactive if they used @signal on that class's fields.\n *\n * This doesn't work all the time, only when the very last class decorated is\n * missing @reactive, but something is better than nothing. There's another\n * similar check performed in the @reactive decorator.\n */\nfunction queueReactiveDecoratorChecker(props: Map<PropKey, PropSpec>) {\n\tif (checkerQueued) return\n\tcheckerQueued = true\n\n\tqueueMicrotask(() => {\n\t\tcheckerQueued = false\n\n\t\t// If the refs are still equal, it means @reactive did not run (forgot\n\t\t// to decorate a class that uses @signal with @reactive).\n\t\tif (props === propsToSignalify) {\n\t\t\tthrow new Error(\n\t\t\t\t// Array.from(map.keys()) instead of [...map.keys()] because it breaks in Oculus browser.\n\t\t\t\t`Stray @signal-decorated properties detected: ${Array.from(props.keys()).join(\n\t\t\t\t\t', ',\n\t\t\t\t)}. Did you forget to use the \\`@reactive\\` decorator on a class that has properties decorated with \\`@signal\\`?`,\n\t\t\t)\n\t\t}\n\t})\n}\n","import type {Constructor} from 'lowclass'\nimport {getListener, untrack} from 'solid-js'\nimport {getKey, getPropsToSignalify, resetPropsToSignalify} from './signal.js'\nimport {getCreateSignalAccessor} from '../signalify.js'\nimport type {DecoratedValue, DecoratorContext} from './types.js'\n\n/**\n * Access key for classy-solid private internal APIs.\n */\nconst accessKey = getKey()\n\nconst createSignalAccessor = getCreateSignalAccessor()\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\n/**\n * A decorator that makes a class reactive, allowing it have properties\n * decorated with `@signal` to make those properties reactive Solid signals.\n *\n * Example:\n *\n * > Note in the following example that `\\@` should be written as `@` without\n * the back slash. The back slash prevents JSDoc parsing errors in this comment\n * in TypeScript.  https://github.com/microsoft/TypeScript/issues/47679\n *\n * ```js\n * import {reactive, signal} from 'classy-solid'\n * import {createEffect} from 'solid-js'\n *\n * \\@reactive\n * class Counter {\n *   \\@signal count = 0\n *\n *   constructor() {\n *     setInterval(() => this.count++, 1000)\n *   }\n * }\n *\n * const counter = new Counter\n *\n * createEffect(() => {\n *   console.log('count:', counter.count)\n * })\n * ```\n */\nexport function reactive(...args: any[]): any {\n\tconst [value, context] = args as [DecoratedValue, DecoratorContext]\n\n\tif (typeof value !== 'function' || (context && context.kind !== 'class'))\n\t\tthrow new TypeError('The @reactive decorator is only for use on classes.')\n\n\tconst Class = value as Constructor\n\tconst props = getPropsToSignalify(accessKey)\n\n\t// For the current class decorated with @reactive, we reset the map, so that\n\t// for the next class decorated with @reactive we track only that next\n\t// class's properties that were decorated with @signal. We do this because\n\t// field decorators do not have access to the class or its prototype.\n\t//\n\t// In the future maybe we can use decorator metadata for this\n\t// (https://github.com/tc39/proposal-decorator-metadata)?\n\tresetPropsToSignalify(accessKey)\n\n\tclass ReactiveDecorator extends Class {\n\t\tconstructor(...args: any[]) {\n\t\t\tlet instance!: ReactiveDecorator\n\n\t\t\tif (getListener()) untrack(() => (instance = Reflect.construct(Class, args, new.target))) // super()\n\t\t\telse super(...args), (instance = this)\n\n\t\t\tfor (const [prop, {initialValue}] of props) {\n\t\t\t\t// @prod-prune\n\t\t\t\tif (!(hasOwnProperty.call(instance, prop) || hasOwnProperty.call(Class.prototype, prop))) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Property \"${prop.toString()}\" not found on object. Did you forget to use the \\`@reactive\\` decorator on a class that has properties decorated with \\`@signal\\`?`,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tcreateSignalAccessor(instance, prop as Exclude<keyof ReactiveDecorator, number>, initialValue)\n\t\t\t}\n\n\t\t\treturn instance\n\t\t}\n\t}\n\n\treturn ReactiveDecorator\n}\n","export * from './component.js'\nexport * from './createDeferredEffect.js'\nexport * from './createSignalFunction.js'\nexport * from './createSignalObject.js'\nexport * from './signalify.js'\n\nexport * from './decorators/index.js'\n\nexport const version = '0.2.3'\n"],"names":["supportsSpread","isSyntaxSupported","supportsClass","supportsNewTarget","TRUE_CONSTRUCTOR","Symbol","setPrototype","Object","setPrototypeOf","object","newPrototype","__proto__","construct","Reflect","Function","instantiator","constructor","args","target","arguments","length","TypeError","prototype","instance","value","apply","SKIP_PROPERTIES","copyProperties","source","destination","getOwnPropertyNames","defineProperty","properties","getOwnPropertySymbols","concat","i","indexOf","getOwnPropertyDescriptor","property","newless","name","usesClassSyntax","toString","substr","requiresNew","newlessConstructor","this","returnValue","error","test","message","Error","create","Node","console","newTarget","hasNewTarget","eval","code","getFunctionBody","setDescriptor","example","useStrict","fn","split","shift","pop","join","descriptorDefaults","enumerable","configurable","obj","key","newDescriptor","inherited","oldDescriptor","writable","get","set","overrideDescriptor","getInheritedDescriptor","descriptor","currentProto","owner","Constructor","Ctor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","d","definition","o","prop","hasOwnProperty","call","r","toStringTag","ImplementationMethod","PROXIES_ON_INSTANCE_AND_PROTOTYPE","WeakMap","sharedConfig","context","registry","$PROXY","$TRACK","signalOptions","equals","a","b","runEffects","runQueue","UNOWNED","owned","cleanups","Owner","Transition","Listener","Updates","Effects","ExecCount","transPending","setTransPending","createSignal","options","s","observers","observerSlots","comparator","assign","readSignal","bind","running","sources","has","tValue","writeSignal","createEffect","runUserEffects","c","createComputation","render","user","push","updateComputation","createMemo","untrack","listener","onCleanup","getOwner","children","memo","resolveChildren","toArray","Array","isArray","runningTransition","tState","state","updates","runUpdates","lookUpstream","sSlot","sourceSlots","node","isComp","current","TransitionRunning","add","disposed","pure","markDownstream","cleanNode","time","runComputation","queueMicrotask","nextValue","err","tOwned","forEach","updatedAt","handleError","init","runTop","suspense","inFallback","effects","ancestors","top","prev","wait","res","promises","size","queue","resolve","e","v","len","completeUpdates","userLength","count","slice","ignore","index","obs","n","cause","castError","results","result","createProvider","id","props","createRenderEffect","component","Base","kind","Class","keys","next","l","onMount","template","defaultValue","createContext","effectQueue","Set","runningEffects","effectDeps","Map","currentEffect","_get","_set","_createSignal","deps","dep","delete","effectTaskIsScheduled","createDeferredEffect","initial","clear","prevListener","runWithOwner","createSignalFunction","createSignalObject","signalifiedProps","signalify","_props","createSignalAccessor","gotCreateSignalAccessor","getCreateSignalAccessor","initialVal","originalGet","originalSet","warn","getSignal","newValue","__propsSetAtLeastOnce__","signals","signalKey","initialValue","propsToSignalify","accessKey","getKey","getPropsToSignalify","resetPropsToSignalify","signal","_","private","isPrivate","static","isStatic","checkerQueued","from","queueReactiveDecoratorChecker","reactive","super","version"],"sourceRoot":""}