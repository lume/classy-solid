{"version":3,"file":"signalify.js","names":["getInheritedDescriptor","createSignal","$PROXY","untrack","signalify","obj","props","proxy","_props","length","Object","keys","concat","getOwnPropertySymbols","prop","isTuple","Array","isArray","_prop","initialValue","createSignalAccessor","gotCreateSignalAccessor","getCreateSignalAccessor","Error","propsSetAtLeastOnce","WeakMap","__isPropSetAtLeastOnce","instance","get","has","trackPropSetAtLeastOnce","set","Set","add","isSignalGetter","WeakSet","initialVal","descriptor","originalGet","originalSet","warnNotReadWrite","value","writable","warnNotWritable","signalStorage","configurable","enumerable","s","getSignal","call","newValue","defineProperty","storage","equals","console","warn","String"],"sources":["../src/signalify.ts"],"sourcesContent":["import {getInheritedDescriptor} from 'lowclass/dist/getInheritedDescriptor.js'\nimport {createSignal, $PROXY, untrack, type Signal} from 'solid-js'\nimport type {PropKey} from './decorators/types.js'\n\ntype AnyObject = Record<PropertyKey, unknown>\n\n/**\n * Convert properties on an object into Solid signal-backed properties.\n *\n * There are two ways to use this: either by defining which properties to\n * convert to signal-backed properties by providing an array as property names\n * in the second arg, which is useful on plain objects, or by passing in `this`\n * and `this.constructor` within the `constructor` of a class that has\n * properties decorated with `@signal`.\n *\n * Example with a class:\n *\n * ```js\n * import {signalify} from 'classy-solid'\n * import {createEffect} from 'solid-js'\n *\n * class Counter {\n *   count = 0\n *\n *   constructor() {\n *     signalify(this, 'count')\n *     setInterval(() => this.count++, 1000)\n *   }\n * }\n *\n * const counter = new Counter\n *\n * createEffect(() => {\n *   console.log('count:', counter.count)\n * })\n * ```\n *\n * Example with a plain object:\n *\n * ```js\n * import {signalify} from 'classy-solid'\n * import {createEffect} from 'solid-js'\n *\n * const counter = {\n *   count: 0\n * }\n *\n * signalify(counter, 'count')\n * setInterval(() => counter.count++, 1000)\n *\n * createEffect(() => {\n *   console.log('count:', counter.count)\n * })\n * ```\n */\nexport function signalify<T extends object, K extends keyof T>(obj: T): T\nexport function signalify<T extends object>(obj: T, ...props: (keyof T)[]): T\nexport function signalify<T extends object>(obj: T, ...props: [key: keyof T, initialValue: unknown][]): T\nexport function signalify(obj: AnyObject, ...props: [key: PropertyKey, initialValue: unknown][] | PropertyKey[]) {\n\t// Special case for Solid proxies: if the object is already a solid proxy,\n\t// all properties are already reactive, no need to signalify.\n\t// @ts-expect-error special indexed access\n\tconst proxy = obj[$PROXY] as T\n\tif (proxy) return obj\n\n\tconst _props = props.length ? props : (Object.keys(obj) as PropKey[]).concat(Object.getOwnPropertySymbols(obj))\n\n\t// Use `untrack` here to be extra safe the initial value doesn't count as a\n\t// dependency and cause a reactivity loop.\n\tfor (const prop of _props) {\n\t\tconst isTuple = Array.isArray(prop)\n\t\t// We cast from PropertyKey to PropKey because keys can't actually be number, only string | symbol.\n\t\tconst _prop = (isTuple ? prop[0] : prop) as PropKey\n\t\tconst initialValue = isTuple ? prop[1] : untrack(() => obj[_prop])\n\n\t\tcreateSignalAccessor(obj, _prop, initialValue)\n\t}\n\n\treturn obj\n}\n\nlet gotCreateSignalAccessor = false\n\n/**\n * This ensures that `createSignalAccessor` is kept internal to classy-solid only.\n */\nexport function getCreateSignalAccessor() {\n\tif (gotCreateSignalAccessor) throw new Error('Export \"createSignalAccessor\" is internal to classy-solid only.')\n\tgotCreateSignalAccessor = true\n\treturn createSignalAccessor\n}\n\n// propsSetAtLeastOnce is a Set that tracks which reactive properties have been\n// set at least once.\nconst propsSetAtLeastOnce = new WeakMap<object, Set<string | symbol>>()\n\n// @lume/element uses this to detect if a reactive prop has been set, and if so\n// will not overwrite the value with any pre-existing value from custom element\n// pre-upgrade.\nexport function __isPropSetAtLeastOnce(instance: object, prop: string | symbol) {\n\treturn !!propsSetAtLeastOnce.get(instance)?.has(prop)\n}\n\nfunction trackPropSetAtLeastOnce(instance: object, prop: string | symbol) {\n\tif (!propsSetAtLeastOnce.has(instance)) propsSetAtLeastOnce.set(instance, new Set())\n\tpropsSetAtLeastOnce.get(instance)!.add(prop)\n}\n\nconst isSignalGetter = new WeakSet<Function>()\n\nfunction createSignalAccessor<T extends object>(obj: T, prop: Exclude<keyof T, number>, initialVal: unknown): void {\n\tlet descriptor: PropertyDescriptor | undefined = getInheritedDescriptor(obj, prop)\n\n\tlet originalGet: (() => any) | undefined\n\tlet originalSet: ((v: any) => void) | undefined\n\n\tif (descriptor) {\n\t\toriginalGet = descriptor.get\n\t\toriginalSet = descriptor.set\n\n\t\tif (originalGet && isSignalGetter.has(originalGet)) return\n\n\t\tif (originalGet || originalSet) {\n\t\t\t// reactivity requires both\n\t\t\tif (!originalGet || !originalSet) return warnNotReadWrite(prop)\n\n\t\t\tdelete descriptor.get\n\t\t\tdelete descriptor.set\n\t\t} else {\n\t\t\t// If there was a value descriptor, trust it as the source of truth\n\t\t\t// for initialVal. For example, if the user class modifies the value\n\t\t\t// after the initializer, it will have a different value than what\n\t\t\t// we tracked from the initializer.\n\t\t\tinitialVal = descriptor.value\n\n\t\t\t// if it isn't writable, we don't need to make a reactive variable because\n\t\t\t// the value won't change\n\t\t\tif (!descriptor.writable) return warnNotWritable(prop)\n\n\t\t\tdelete descriptor.value\n\t\t\tdelete descriptor.writable\n\t\t}\n\t}\n\n\tconst signalStorage = new WeakMap<object, Signal<unknown>>()\n\n\tdescriptor = {\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\t...descriptor,\n\t\tget: originalGet\n\t\t\t? function (this: object): unknown {\n\t\t\t\t\tconst s = getSignal(this, signalStorage, initialVal)\n\t\t\t\t\ts[0]() // read\n\t\t\t\t\treturn originalGet!.call(this)\n\t\t\t  }\n\t\t\t: function (this: object): unknown {\n\t\t\t\t\tconst s = getSignal(this, signalStorage, initialVal)\n\t\t\t\t\treturn s[0]() // read\n\t\t\t  },\n\t\tset: originalSet\n\t\t\t? function (this: object, newValue: unknown) {\n\t\t\t\t\toriginalSet!.call(this, newValue)\n\n\t\t\t\t\ttrackPropSetAtLeastOnce(this, prop)\n\n\t\t\t\t\t// write\n\t\t\t\t\tconst s = getSignal(this, signalStorage, initialVal)\n\t\t\t\t\tif (typeof newValue === 'function') s[1](() => newValue)\n\t\t\t\t\telse s[1](newValue)\n\t\t\t  }\n\t\t\t: function (this: object, newValue: unknown) {\n\t\t\t\t\ttrackPropSetAtLeastOnce(this, prop)\n\n\t\t\t\t\t// write\n\t\t\t\t\tconst s = getSignal(this, signalStorage, initialVal)\n\t\t\t\t\tif (typeof newValue === 'function') s[1](() => newValue)\n\t\t\t\t\telse s[1](newValue)\n\t\t\t  },\n\t}\n\n\tisSignalGetter.add(descriptor.get!)\n\n\tObject.defineProperty(obj, prop, descriptor)\n}\n\nfunction getSignal(obj: object, storage: WeakMap<object, Signal<unknown>>, initialVal: unknown) {\n\tlet s = storage.get(obj)\n\tif (!s) storage.set(obj, (s = createSignal(initialVal, {equals: false})))\n\treturn s\n}\n\nfunction warnNotReadWrite(prop: PropertyKey) {\n\tconsole.warn(\n\t\t`Cannot signalify property named \"${String(\n\t\t\tprop,\n\t\t)}\" which had a getter or a setter, but not both. Reactivity on accessors works only when accessors have both get and set. Skipped.`,\n\t)\n}\n\nfunction warnNotWritable(prop: PropertyKey) {\n\tconsole.warn(\n\t\t`The \\`@signal\\` decorator was used on a property named \"${String(\n\t\t\tprop,\n\t\t)}\" that is not writable. Reactivity is not enabled for non-writable properties.`,\n\t)\n}\n"],"mappings":"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","ignoreList":[]}