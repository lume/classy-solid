{"version":3,"file":"signalify.js","names":["getInheritedDescriptor","$PROXY","batch","untrack","createSignalFunction","isMemoGetter","isSignalGetter","signalify","obj","props","proxy","skipFunctionProperties","length","_props","Object","keys","concat","getOwnPropertySymbols","prop","isTuple","Array","isArray","_prop","initialValue","createSignalAccessor__","propsSetAtLeastOnce","WeakMap","isPropSetAtLeastOnce__","instance","get","has","trackPropSetAtLeastOnce__","set","Set","add","initialVal","descriptor","originalGet","originalSet","isAccessor","value","writable","warnNotWritable","signalStorage","newDescriptor","configurable","enumerable","getSignal__","call","newValue","s","defineProperty","storage","equals","console","warn","String"],"sources":["../../src/signals/signalify.ts"],"sourcesContent":["import {getInheritedDescriptor} from 'lowclass/dist/getInheritedDescriptor.js'\nimport {$PROXY, batch, untrack} from 'solid-js'\nimport type {PropKey} from '../decorators/types.js'\nimport {createSignalFunction, type SignalFunction} from './createSignalFunction.js'\nimport {isMemoGetter, isSignalGetter} from '../_state.js'\n\ntype AnyObject = Record<PropertyKey, unknown>\n\n/**\n * Convert properties on an object into Solid signal-backed properties.\n *\n * There are two ways to use this:\n *\n * 1. Define which properties to convert to signal-backed properties by\n * providing property names as trailing arguments. Properties that are\n * function-valued (methods) are included as values of the signal properties.\n * 2. If no property names are provided, all non-function-valued properties on\n * the object will be automatically converted to signal-backed properties.\n *\n * If any property is already memoified with `memoify()`, or already signalified\n * with `signalify()`, it will be skipped.\n *\n * Example with a class:\n *\n * ```js\n * import {signalify} from 'classy-solid'\n * import {createEffect} from 'solid-js'\n *\n * class Counter {\n *   count = 0\n *\n *   constructor() {\n *     signalify(this, 'count')\n *     setInterval(() => this.count++, 1000)\n *   }\n * }\n *\n * const counter = new Counter\n *\n * createEffect(() => {\n *   console.log('count:', counter.count)\n * })\n * ```\n *\n * Example with a plain object:\n *\n * ```js\n * import {signalify} from 'classy-solid'\n * import {createEffect} from 'solid-js'\n *\n * const counter = {\n *   count: 0\n * }\n *\n * signalify(counter, 'count')\n * setInterval(() => counter.count++, 1000)\n *\n * createEffect(() => {\n *   console.log('count:', counter.count)\n * })\n * ```\n */\nexport function signalify<T extends object, K extends keyof T>(obj: T): T\nexport function signalify<T extends object>(obj: T, ...props: (keyof T)[]): T\n/** This overload is for initial value support for downstream use cases. */\nexport function signalify<T extends object>(obj: T, ...props: [key: keyof T, initialValue: unknown][]): T\nexport function signalify(obj: AnyObject, ...props: [key: PropertyKey, initialValue: unknown][] | PropertyKey[]) {\n\t// Special case for Solid proxies: if the object is already a solid proxy,\n\t// all properties are already reactive, no need to signalify.\n\t// @ts-expect-error special indexed access\n\tconst proxy = obj[$PROXY] as T\n\tif (proxy) return obj\n\n\tconst skipFunctionProperties = props.length === 0\n\n\tconst _props = props.length ? props : (Object.keys(obj) as PropKey[]).concat(Object.getOwnPropertySymbols(obj))\n\n\t// Use `untrack` here to be extra safe the initial value doesn't count as a\n\t// dependency and cause a reactivity loop.\n\tfor (const prop of _props) {\n\t\tconst isTuple = Array.isArray(prop)\n\t\t// We cast from PropertyKey to PropKey because keys can't actually be number, only string | symbol.\n\t\tconst _prop = (isTuple ? prop[0] : prop) as PropKey\n\t\tconst initialValue = isTuple ? prop[1] : untrack(() => obj[_prop])\n\n\t\tcreateSignalAccessor__(obj, _prop, initialValue, skipFunctionProperties)\n\t}\n\n\treturn obj\n}\n\n// propsSetAtLeastOnce is a Set that tracks which reactive properties have been\n// set at least once.\nconst propsSetAtLeastOnce = new WeakMap<object, Set<string | symbol>>()\n\n// @lume/element uses this to detect if a reactive prop has been set, and if so\n// will not overwrite the value with any pre-existing value from custom element\n// pre-upgrade.\nexport function isPropSetAtLeastOnce__(instance: object, prop: string | symbol) {\n\treturn !!propsSetAtLeastOnce.get(instance)?.has(prop)\n}\n\nexport function trackPropSetAtLeastOnce__(instance: object, prop: string | symbol) {\n\tif (!propsSetAtLeastOnce.has(instance)) propsSetAtLeastOnce.set(instance, new Set())\n\tpropsSetAtLeastOnce.get(instance)!.add(prop)\n}\n\nexport function createSignalAccessor__<T extends object>(\n\tobj: T,\n\tprop: Exclude<keyof T, number>,\n\tinitialVal: unknown,\n\tskipFunctionProperties = false,\n): void {\n\tlet descriptor: PropertyDescriptor | undefined = getInheritedDescriptor(obj, prop)\n\n\tlet originalGet: (() => any) | undefined\n\tlet originalSet: ((v: any) => void) | undefined\n\tconst isAccessor = !!(descriptor?.get || descriptor?.set)\n\n\tif (descriptor) {\n\t\tif (skipFunctionProperties && typeof descriptor.value === 'function') return\n\n\t\toriginalGet = descriptor.get\n\t\toriginalSet = descriptor.set\n\n\t\t// If the original getter is already a signal getter, skip re-signalifying.\n\t\tif (originalGet && isSignalGetter.has(originalGet)) return\n\n\t\t// If the original getter is already a memo getter, skip signalifying.\n\t\tif (originalGet && isMemoGetter.has(originalGet)) return\n\n\t\t// Signals require both getter and setter to work properly.\n\t\tif (isAccessor && !(originalGet && originalSet)) return\n\n\t\tif (!isAccessor) {\n\t\t\t// No need to make a signal that can't be written to.\n\t\t\tif (!descriptor.writable) return warnNotWritable(prop)\n\n\t\t\t// If there was a value descriptor, trust it as the source of truth\n\t\t\t// for initialVal. For example, if the user class modifies the value\n\t\t\t// after the initializer, it will have a different value than what\n\t\t\t// we tracked from the initializer.\n\t\t\tinitialVal = descriptor.value\n\t\t}\n\t}\n\n\tconst signalStorage = new WeakMap<object, SignalFunction<unknown>>()\n\n\tconst newDescriptor = {\n\t\tconfigurable: true,\n\t\tenumerable: descriptor?.enumerable,\n\t\tget: isAccessor\n\t\t\t? function (this: object): unknown {\n\t\t\t\t\tgetSignal__(this, signalStorage, initialVal)()\n\t\t\t\t\treturn originalGet!.call(this)\n\t\t\t  }\n\t\t\t: function (this: object): unknown {\n\t\t\t\t\treturn getSignal__(this, signalStorage, initialVal)()\n\t\t\t  },\n\t\tset: isAccessor\n\t\t\t? function (this: object, newValue: unknown) {\n\t\t\t\t\t// batch, for example in case setter calls super setter, to\n\t\t\t\t\t// avoid multiple effect runs on a single property set.\n\t\t\t\t\tbatch(() => {\n\t\t\t\t\t\toriginalSet!.call(this, newValue)\n\t\t\t\t\t\ttrackPropSetAtLeastOnce__(this, prop)\n\n\t\t\t\t\t\tconst s = getSignal__(this, signalStorage, initialVal)\n\t\t\t\t\t\ts(typeof newValue === 'function' ? () => newValue : newValue)\n\t\t\t\t\t})\n\t\t\t  }\n\t\t\t: function (this: object, newValue: unknown) {\n\t\t\t\t\ttrackPropSetAtLeastOnce__(this, prop)\n\n\t\t\t\t\tconst s = getSignal__(this, signalStorage, initialVal)\n\t\t\t\t\ts(typeof newValue === 'function' ? () => newValue : newValue)\n\t\t\t  },\n\t}\n\n\tisSignalGetter.add(newDescriptor.get!)\n\n\tObject.defineProperty(obj, prop, newDescriptor)\n}\n\nexport function getSignal__(obj: object, storage: WeakMap<object, SignalFunction<unknown>>, initialVal: unknown) {\n\tlet s = storage.get(obj)\n\tif (!s) storage.set(obj, (s = createSignalFunction(initialVal, {equals: false})))\n\treturn s\n}\n\nfunction warnNotWritable(prop: PropertyKey) {\n\tconsole.warn(\n\t\t`The \\`@signal\\` decorator was used on a property named \"${String(\n\t\t\tprop,\n\t\t)}\" that is not writable. Reactivity is not enabled for non-writable properties.`,\n\t)\n}\n"],"mappings":"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","ignoreList":[]}